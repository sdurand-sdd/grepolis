<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Villes Grepolis</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        .map-container { cursor: grab; }
        .map-container:active { cursor: grabbing; }
        .distance-line { stroke-dasharray: 5,5; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -10; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, useRef } = React;

        // --- Fonctions de base et de parsing (hors composant) ---

        // Calcul de la distance Grepolis entre deux coordonn√©es (x, y)
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x1 - x1, 2) + Math.pow(y1 - y2, 2)).toFixed(2);
        };

        // Retourne le format 2 chiffres (XY) pour l'affichage (ex: "24" pour Oc√©an 24).
        const getGrepolisOcean = (x, y) => {
            const oceanX = Math.floor(x / 100).toString(); 
            const oceanY = Math.floor(y / 100).toString();
            return oceanX.padStart(1, '0') + oceanY.padStart(1, '0'); 
        };
        
        // Fonction g√©n√©rique pour parser les fichiers TXT (suppos√©s √™tre CSV)
        const parseData = (text, headers) => {
            const lines = text.trim().split('\n').filter(line => line.trim() !== '' && !line.startsWith('#'));
            if (lines.length === 0) return [];
            
            return lines.map(line => {
                // Utilisation de la virgule (,) comme d√©limiteur
                const values = line.split(','); 
                const obj = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    // Tente de convertir en nombre si ce n'est pas un nom
                    obj[header] = (header.endsWith('_id') || ['id', 'x', 'y', 'points', 'towns', 'members', 'rank', 'off_rank', 'off_points', 'def_rank', 'def_points'].includes(header)) ? (Number(value) || 0) : value;
                });
                return obj;
            }).filter(obj => Object.keys(obj).length === headers.length);
        };

        // Fonction pour charger et fusionner toutes les donn√©es
        const fetchData = async () => {
            const BASE_URL = ''; // Fichiers dans le m√™me dossier que l'HTML

            try {
                const [alliancesRes, playersRes, townsRes] = await Promise.all([
                    fetch(`${BASE_URL}alliances.txt`),
                    fetch(`${BASE_URL}players.txt`),
                    fetch(`${BASE_URL}towns.txt`),
                ]);

                // V√©rification des erreurs de chargement
                if (!alliancesRes.ok || !playersRes.ok || !townsRes.ok) {
                    throw new Error("Erreur de chargement d'un des fichiers TXT.");
                }

                const [alliancesText, playersText, townsText] = await Promise.all([
                    alliancesRes.text(),
                    playersRes.text(),
                    townsRes.text(),
                ]);

                // En-t√™tes Grepolis typiques (ajustez si vos fichiers sont diff√©rents)
                const alliancesHeaders = ['id', 'name', 'points', 'towns', 'members'];
                const playersHeaders = ['id', 'name', 'alliance_id', 'points', 'rank', 'towns', 'off_rank', 'off_points', 'def_rank', 'def_points'];
                const townsHeaders = ['id', 'player_id', 'name', 'x', 'y', 'points', 'type']; 

                const alliances = parseData(alliancesText, alliancesHeaders);
                const players = parseData(playersText, playersHeaders);
                const towns = parseData(townsText, townsHeaders);

                // Mapping pour un acc√®s rapide
                const allianceMap = new Map(alliances.map(a => [a.id, a]));
                const playerMap = new Map(players.map(p => [p.id, {
                    ...p,
                    alliance_name: allianceMap.get(p.alliance_id)?.name || 'Sans alliance',
                    alliance_members: allianceMap.get(p.alliance_id)?.members || 0
                }]));

                // Fusion des donn√©es : Cr√©ation de la liste de villes enrichie
                const mergedCities = towns.map(town => {
                    const player = playerMap.get(town.player_id);
                    if (!player || town.points === 0) return null; // Ignore les villes sans joueur ou barbares (points=0)

                    return {
                        ...town,
                        ocean: getGrepolisOcean(town.x, town.y), // Calcul de l'oc√©an corrig√© (2 chiffres)
                        player_name: player.name,
                        player_id: player.id,
                        player_points: player.points,
                        player_towns_count: player.towns,
                        alliance_id: player.alliance_id,
                        alliance_name: player.alliance_name,
                        alliance_members: player.alliance_members,
                        player_off_points: player.off_points,
                        player_def_points: player.def_points,
                    };
                }).filter(c => c !== null);

                return mergedCities;

            } catch (error) {
                console.error("Erreur lors du chargement des donn√©es Grepolis:", error);
                throw new Error("Erreur de chargement des donn√©es. Assurez-vous que les fichiers towns.txt, players.txt et alliances.txt sont pr√©sents √† la racine.");
            }
        };

        /**
         * Fonction utilitaire pour g√©n√©rer une couleur HSL unique
         * pour chacun des 100 oc√©ans (00 √† 99) de mani√®re d√©terministe.
         */
        const generateColor = (id) => {
            const num = parseInt(id, 10);
            // Utilise HSL pour une bonne distribution des couleurs
            const hue = (num * 6) % 360; 
            const saturation = 70; 
            const lightness = 60; 
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };


        // --- Composant Principal de la Carte ---

        const GrepolisMap = () => {
            const [cities, setCities] = useState([]);
            const [loading, setLoading] = useState(true);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [search, setSearch] = useState('');
            const [playerSearch, setPlayerSearch] = useState(''); 
            const [selectedOcean, setSelectedOcean] = useState('all');
            const [hoveredCity, setHoveredCity] = useState(null);
            const [selectedCity, setSelectedCity] = useState(null);
            const [distanceMode, setDistanceMode] = useState(false);
            const [citiesForDistance, setCitiesForDistance] = useState([]);
            const [dataError, setDataError] = useState(null);
            
            // R√©f√©rence pour la zone de carte afin d'attacher un √©couteur d'√©v√©nement non passif
            const mapRef = useRef(null); 

            const viewMode = 'detailed'; 
            const showSubGrid = true; 

            // G√©n√©ration de 100 couleurs d'oc√©an uniques
            const oceanColors = useMemo(() => {
                const colors = {};
                for (let i = 0; i < 100; i++) {
                    const id = i.toString().padStart(2, '0'); // '00', '01', ..., '99'
                    colors[id] = generateColor(id);
                }
                return colors;
            }, []);

            // Calcul des limites des villes pour le zoom automatique
            const mapBounds = useMemo(() => {
                const targetCities = cities.filter(city => city.player_name.toLowerCase().includes(playerSearch.toLowerCase()) && city.name.toLowerCase().includes(search.toLowerCase()) && (selectedOcean === 'all' || city.ocean === selectedOcean));
                
                if (targetCities.length === 0) return { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                
                const xs = targetCities.map(c => c.x);
                const ys = targetCities.map(c => c.y);
                const minX = Math.max(0, Math.min(...xs) - 50);
                const maxX = Math.min(1000, Math.max(...xs) + 50);
                const minY = Math.max(0, Math.min(...ys) - 50);
                const maxY = Math.min(1000, Math.max(...ys) + 50);
                return { minX, maxX, minY, maxY };
            }, [cities, search, playerSearch, selectedOcean]);


            // Zoom automatique sur les zones occup√©es 
            const zoomToOccupiedAreas = useCallback((bounds = mapBounds) => {
                if (cities.length === 0) return;
                
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                const mapWidth = 800; // Taille arbitraire d'affichage
                const mapHeight = 600;

                const scaleX = mapWidth / width; 
                const scaleY = mapHeight / height; 
                const scale = Math.min(scaleX, scaleY, 10); 

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                
                setTransform({
                    x: (1000 / 2) - centerX * scale, 
                    y: (1000 / 2) - centerY * scale, 
                    scale: scale
                });
            }, [cities.length, mapBounds]);


            // Gestion du zoom (Molette) - Correction de l'avertissement passive listener
            const handleWheel = useCallback((e) => {
                e.preventDefault(); 
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                setTransform(prev => ({ 
                    ...prev, 
                    scale: Math.max(0.1, Math.min(10, prev.scale * scale)) 
                }));
            }, []);
            
            // Attacher l'√©couteur `wheel` non passif
            useEffect(() => {
                const mapElement = mapRef.current;
                if (mapElement) {
                    mapElement.addEventListener('wheel', handleWheel, { passive: false });
                    
                    return () => {
                        mapElement.removeEventListener('wheel', handleWheel);
                    };
                }
            }, [handleWheel]); 


            // Chargement des donn√©es au montage du composant
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const data = await fetchData();
                        setCities(data);
                        const initialBounds = { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                        zoomToOccupiedAreas(initialBounds); 
                    } catch (err) {
                        setDataError(err.message);
                    } finally {
                        setLoading(false);
                    }
                };
                loadData();
            }, []);
            
            // Appliquer le zoom apr√®s le filtrage
            useEffect(() => {
                if (!loading && cities.length > 0) {
                    zoomToOccupiedAreas(mapBounds);
                }
            }, [search, playerSearch, selectedOcean, loading, cities.length, zoomToOccupiedAreas, mapBounds]);
            

            // Logique de filtrage 
            const filteredCities = useMemo(() => {
                const lowerCaseSearch = search.toLowerCase();
                const lowerCasePlayerSearch = playerSearch.toLowerCase(); 

                return cities.filter(city => {
                    const matchTown = city.name.toLowerCase().includes(lowerCaseSearch); 
                    const matchPlayer = city.player_name.toLowerCase().includes(lowerCasePlayerSearch); 

                    const matchOcean = selectedOcean === 'all' || city.ocean === selectedOcean;
                    return matchTown && matchPlayer && matchOcean;
                });
            }, [cities, search, playerSearch, selectedOcean]);

            // Groupement des villes par coordonn√©es 
            const groupedCities = useMemo(() => {
                const groups = {};
                filteredCities.forEach(city => {
                    const key = `${city.x},${city.y}`;
                    if (!groups[key]) {
                        groups[key] = [];
                    }
                    groups[key].push(city);
                });
                return groups;
            }, [filteredCities]);

            // Oc√©ans disponibles (pour le filtre)
            const oceans = useMemo(() => {
                // Utilise padStart pour s'assurer que l'oc√©an 2 est "02" pour le tri
                const allOceans = ['all', ...new Set(cities.map(c => c.ocean))];
                return allOceans.sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return parseInt(a) - parseInt(b);
                });
            }, [cities]);

            // Gestion du d√©placement (Mouse) 
            const handleMouseDown = useCallback((e) => {
                setIsDragging(true);
                setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
            }, [transform]);

            const handleMouseMove = useCallback((e) => {
                if (!isDragging) return;
                setTransform(prev => ({
                    ...prev,
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                }));
            }, [isDragging, dragStart]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);
            
            const handleCityClick = useCallback((city) => {
                if (distanceMode) {
                    setCitiesForDistance(prev => {
                        if (prev.length === 0) {
                            return [city];
                        } else if (prev.length === 1) {
                            if (prev[0].id === city.id) return []; // Deselect
                            return [...prev, city];
                        } else {
                            return [city];
                        }
                    });
                } else {
                    setSelectedCity(prev => (prev && prev.id === city.id ? null : city));
                }
            }, [distanceMode]);

            const resetDistanceMode = useCallback(() => {
                setDistanceMode(false);
                setCitiesForDistance([]);
            }, []);
            
            // Rendu des carr√©s d'oc√©an
            const renderOceanSquares = useCallback(() => {
                const oceanSquares = [];
                for (let x = 0; x < 10; x++) {
                    for (let y = 0; y < 10; y++) {
                        const grepolisOceanNum = getGrepolisOcean(x * 100 + 1, y * 100 + 1); 
                        const isOccupied = cities.some(city => city.ocean === grepolisOceanNum);
                        const oceanX = x;
                        const oceanY = y;
                        const isEven = (oceanX % 2 === 0) === (oceanY % 2 === 0); 
                        
                        if (viewMode === 'detailed' || isOccupied) { 
                            oceanSquares.push(
                                <g key={grepolisOceanNum}>
                                    <rect 
                                        x={oceanX * 100} y={oceanY * 100} 
                                        width={100} height={100} 
                                        fill={isEven ? '#1e3a5f' : '#2d4a6f'} 
                                        stroke="#0f172a" strokeWidth="0.5" 
                                        opacity={isOccupied ? 1 : 0.3} 
                                    />
                                    <text 
                                        x={oceanX * 100 + 50} y={oceanY * 100 + 50} 
                                        textAnchor="middle" dy="0.35em" 
                                        fill={isOccupied ? '#fbbf24' : '#64748b'} 
                                        fontSize="12" fontWeight="bold" 
                                        opacity={isOccupied ? 0.9 : 0.3} 
                                    >
                                        {grepolisOceanNum} 
                                    </text>
                                </g>
                            );
                        }
                    }
                }
                return oceanSquares;
            }, [cities]);
            
            // Rendu de la grille secondaire 5x5
            const renderSubGrid = useCallback(() => {
                if (!showSubGrid) return null; 

                const subGridLines = [];
                for (let x = 0; x <= 1000; x += 20) {
                    subGridLines.push(
                        <line key={`vline-${x}`} x1={x} y1={0} x2={x} y2={1000} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                for (let y = 0; y <= 1000; y += 20) {
                    subGridLines.push(
                        <line key={`hline-${y}`} x1={0} y1={y} x2={1000} y2={y} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                return subGridLines;
            }, []);

            // Rendu des lignes de distance
            const renderDistanceLines = useCallback(() => {
                if (citiesForDistance.length < 2) return null;
                const [city1, city2] = citiesForDistance;
                const distance = calculateDistance(city1.x, city1.y, city2.x, city2.y);
                return (
                    <g>
                        <line x1={city1.x} y1={city1.y} x2={city2.x} y2={city2.y} 
                            stroke="#10b981" strokeWidth="1.5" className="distance-line" />
                        
                        <text 
                            x={(city1.x + city2.x) / 2} y={(city1.y + city2.y) / 2} 
                            textAnchor="middle" dy="-0.5em" 
                            fill="#10b981" fontSize={Math.max(4, 14 / transform.scale)} 
                            fontWeight="bold" 
                            style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                        >
                            {distance}
                        </text>
                    </g>
                );
            }, [citiesForDistance, transform.scale]);

            // Rendu des villes
            const renderCities = useMemo(() => {
                return Object.entries(groupedCities).map(([key, citiesAtLocation]) => {
                    const [x, y] = key.split(',').map(Number);
                    const city = citiesAtLocation[0]; 
                    // city.ocean correspond √† une cl√© dans oceanColors (qui a maintenant 100 couleurs)
                    const oceanColor = oceanColors[city.ocean] || '#ccc'; 
                    const isHovered = hoveredCity && hoveredCity.x === x && hoveredCity.y === y;
                    const isSelected = selectedCity && selectedCity.x === x && selectedCity.y === y;
                    const isInDistanceSelection = citiesForDistance.some(c => c.x === x && c.y === y);

                    return (
                        <g key={key}>
                            {/* Cercle principal de la ville/cluster */}
                            <circle 
                                cx={x} cy={y} 
                                r={Math.max(1, 4 / transform.scale)} 
                                fill={oceanColor} 
                                stroke={isInDistanceSelection ? '#10b981' : (isSelected ? '#fff' : isHovered ? '#fff' : oceanColor)} 
                                strokeWidth={isInDistanceSelection ? 2 : (isSelected ? 1.5 : isHovered ? 1 : 0)}
                                opacity={isInDistanceSelection ? 1 : (isHovered || isSelected ? 1 : 0.9)}
                                onMouseEnter={() => setHoveredCity(citiesAtLocation[0])}
                                onMouseLeave={() => setHoveredCity(null)}
                                onClick={() => handleCityClick(citiesAtLocation[0])}
                                style={{ cursor: 'pointer' }}
                            />
                            {/* Indicateur de nombre pour les clusters */}
                            {citiesAtLocation.length > 1 && (
                                <text 
                                    x={x} y={y} 
                                    textAnchor="middle" dy="0.3em" 
                                    fill="white" 
                                    fontSize={Math.max(3, 8 / transform.scale)} 
                                    fontWeight="bold" 
                                    style={{ pointerEvents: 'none' }}
                                >
                                    {citiesAtLocation.length}
                                </text>
                            )}
                            {/* Tooltip au survol/s√©lection */}
                            {(isHovered || isSelected) && !distanceMode && transform.scale > 0.5 && (
                                <>
                                    <text 
                                        x={x} y={y - 8 - (10 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#fbbf24" 
                                        fontSize={Math.max(4, 12 / transform.scale)} 
                                        fontWeight="bold" 
                                        style={{ pointerEvents: 'none' }}
                                    >
                                        {citiesAtLocation[0].name}
                                    </text>
                                    <text 
                                        x={x} y={y - 4 - (5 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#94a3b8" 
                                        fontSize={Math.max(3, 10 / transform.scale)} 
                                        style={{ pointerEvents: 'none' }}
                                    >
                                        ({x}, {y}) - {citiesAtLocation[0].player_name}
                                    </text>
                                </>
                            )}
                        </g>
                    );
                });
            }, [groupedCities, hoveredCity, selectedCity, citiesForDistance, oceanColors, distanceMode, handleCityClick, transform.scale]);
            
            // Composant de l'en-t√™te
            const renderHeader = () => (
                <div className="bg-slate-800 p-4 shadow-lg">
                    <h1 className="text-2xl font-bold text-amber-400 mb-4 flex items-center gap-2">
                         <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0l-4.243-4.243m10.606 0a2 2 0 110-2 2 2 0 010 2zm-10.606 0a2 2 0 110-2 2 2 0 010 2zM6 10h2m4 0h2m4 0h2m-10 0V4h12v6" />
                        </svg>
                        Carte des Villes de l'Alliance
                    </h1>
                    
                    <div className="flex flex-wrap items-center gap-3">
                        {/* Rechercher une ville */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="üîç Rechercher une ville..."
                                value={search}
                                onChange={(e) => setSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-60 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                        </div>

                        {/* Rechercher un joueur (ATTENTION : Cette ligne doit rester en une seule ligne pour √©viter l'erreur de cha√Æne non termin√©e) */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="üë§ Rechercher un joueur..."
                                value={playerSearch}
                                onChange={(e) => setPlayerSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-60 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14c3.486 0 5.122 1.981 5.64 3.551.493 1.52-.39 2.449-1.957 2.449H8.317c-1.567 0-2.45-1.129-1.957-2.449C6.878 15.981 8.514 14 12 14z" /></svg>
                        </div>
                        
                        {/* Filtre Oc√©an */}
                        <select
                            value={selectedOcean}
                            onChange={(e) => setSelectedOcean(e.target.value)}
                            className="bg-slate-700 text-white py-2 px-3 rounded-lg focus:ring-amber-500 focus:border-amber-500"
                        >
                            {oceans.map(ocean => (
                                <option key={ocean} value={ocean}>
                                    {ocean === 'all' ? 'Tous les Oc√©ans' : `Oc√©an ${ocean}`}
                                </option>
                            ))}
                        </select>
                        
                        {/* Boutons de contr√¥le */}
                        <div className="flex flex-wrap gap-2">
                            <button onClick={() => setDistanceMode(!distanceMode)} className={`px-3 py-2 rounded-lg transition-colors ${ 
                                distanceMode ? 'bg-green-500 hover:bg-green-600 text-white' : 'bg-slate-600 hover:bg-slate-500 text-slate-300' 
                            }`}> 
                                üìè Distance 
                            </button>
                            <button onClick={() => zoomToOccupiedAreas(mapBounds)} className="px-3 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 transition-colors" > 
                                üîç Zoom Zones 
                            </button>
                            <button onClick={() => setTransform({ x: 0, y: 0, scale: 1 })} className="px-3 py-2 bg-slate-600 text-slate-300 rounded-lg hover:bg-slate-500 transition-colors" > 
                                Reset Zoom 
                            </button>
                        </div>
                    </div>

                    <div className="mt-3 text-slate-300 text-sm flex gap-4 flex-wrap">
                        {loading ? (
                            <span className="text-amber-400 font-semibold">Chargement des donn√©es...</span>
                        ) : dataError ? (
                            <span className="text-red-400 font-semibold">Erreur de donn√©es: {dataError}</span>
                        ) : (
                            <>
                                <span> 
                                    <span className="font-semibold text-amber-400">{filteredCities.length}</span> villes affich√©es 
                                </span>
                                <span> 
                                    <span className="font-semibold text-amber-400">{Object.keys(groupedCities).length}</span> positions uniques 
                                </span>
                                <span> 
                                    <span className="font-semibold text-amber-400">{cities.length}</span> villes totales 
                                </span>
                            </>
                        )}
                        {distanceMode && (
                            <span className="text-green-400 font-semibold"> üìè Mode Distance Activ√© - Cliquez sur 2 villes </span>
                        )}
                        {viewMode === 'detailed' && (
                            <span className="text-blue-400 font-semibold"> üåç Vue D√©taill√©e (Par d√©faut) </span>
                        )}
                        {showSubGrid && (
                            <span className="text-purple-400 font-semibold"> üìè Grille 5x5 Activ√©e (Par d√©faut) </span>
                        )}
                    </div>
                </div>
            );


            // Composant de la Barre Lat√©rale (inchang√©)
            const renderSidebar = () => {
                const targetCity = selectedCity || hoveredCity;

                if (loading) {
                    return (
                        <div className="w-80 p-4 bg-slate-800 text-slate-300 flex-shrink-0 overflow-y-auto">
                            <div className="text-center py-10">
                                <p className="text-amber-400">Chargement des donn√©es...</p>
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-amber-400 mx-auto mt-4"></div>
                            </div>
                        </div>
                    );
                }
                
                if (dataError) {
                    return (
                        <div className="w-80 p-4 bg-slate-800 text-slate-300 flex-shrink-0 overflow-y-auto">
                             <div className="text-center py-10">
                                <p className="text-red-400 font-bold
