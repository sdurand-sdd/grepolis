<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Villes Grepolis</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        .map-container { cursor: grab; }
        .map-container:active { cursor: grabbing; }
        .distance-line { stroke-dasharray: 5,5; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -10; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, useRef } = React; // <-- AJOUT DE useRef

        // --- Fonctions de base et de parsing (hors composant) ---

        // Calcul de la distance Grepolis entre deux coordonnÃ©es (x, y)
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)).toFixed(2);
        };

        /**
         * FIX 1: Calcul de l'ocÃ©an Grepolis
         * Retourne le format 2 chiffres (XY) pour l'affichage (ex: "24" pour OcÃ©an 24).
         */
        const getGrepolisOcean = (x, y) => {
            // oceanX et oceanY sont les coordonnÃ©es (0-9) du carrÃ© d'ocÃ©an 100x100
            const oceanX = Math.floor(x / 100).toString(); 
            const oceanY = Math.floor(y / 100).toString();
            // ConcatÃ¨ne les deux chiffres (ex: "2" + "4" -> "24")
            return oceanX + oceanY; 
        };
        
        // Fonction gÃ©nÃ©rique pour parser les fichiers TXT (supposÃ©s Ãªtre CSV)
        const parseData = (text, headers) => {
            const lines = text.trim().split('\n').filter(line => line.trim() !== '' && !line.startsWith('#'));
            if (lines.length === 0) return [];
            
            return lines.map(line => {
                // Utilisation de la virgule (,) comme dÃ©limiteur
                const values = line.split(','); 
                const obj = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    // Tente de convertir en nombre si ce n'est pas un nom
                    obj[header] = (header.endsWith('_id') || ['id', 'x', 'y', 'points', 'towns', 'members', 'rank', 'off_rank', 'off_points', 'def_rank', 'def_points'].includes(header)) ? (Number(value) || 0) : value;
                });
                return obj;
            }).filter(obj => Object.keys(obj).length === headers.length);
        };

        // Fonction pour charger et fusionner toutes les donnÃ©es
        const fetchData = async () => {
            const BASE_URL = ''; // Fichiers dans le mÃªme dossier que l'HTML

            try {
                const [alliancesRes, playersRes, townsRes] = await Promise.all([
                    fetch(`${BASE_URL}alliances.txt`),
                    fetch(`${BASE_URL}players.txt`),
                    fetch(`${BASE_URL}towns.txt`),
                ]);

                // VÃ©rification des erreurs de chargement
                if (!alliancesRes.ok || !playersRes.ok || !townsRes.ok) {
                    throw new Error("Erreur de chargement d'un des fichiers TXT.");
                }

                const [alliancesText, playersText, townsText] = await Promise.all([
                    alliancesRes.text(),
                    playersRes.text(),
                    townsRes.text(),
                ]);

                // En-tÃªtes Grepolis typiques (ajustez si vos fichiers sont diffÃ©rents)
                const alliancesHeaders = ['id', 'name', 'points', 'towns', 'members'];
                const playersHeaders = ['id', 'name', 'alliance_id', 'points', 'rank', 'towns', 'off_rank', 'off_points', 'def_rank', 'def_points'];
                const townsHeaders = ['id', 'player_id', 'name', 'x', 'y', 'points', 'type']; 

                const alliances = parseData(alliancesText, alliancesHeaders);
                const players = parseData(playersText, playersHeaders);
                const towns = parseData(townsText, townsHeaders);

                // Mapping pour un accÃ¨s rapide
                const allianceMap = new Map(alliances.map(a => [a.id, a]));
                const playerMap = new Map(players.map(p => [p.id, {
                    ...p,
                    alliance_name: allianceMap.get(p.alliance_id)?.name || 'Sans alliance',
                    alliance_members: allianceMap.get(p.alliance_id)?.members || 0
                }]));

                // Fusion des donnÃ©es : CrÃ©ation de la liste de villes enrichie
                const mergedCities = towns.map(town => {
                    const player = playerMap.get(town.player_id);
                    if (!player || town.points === 0) return null; // Ignore les villes sans joueur ou barbares (points=0)

                    return {
                        ...town,
                        ocean: getGrepolisOcean(town.x, town.y), // Calcul de l'ocÃ©an corrigÃ© (2 chiffres)
                        player_name: player.name,
                        player_id: player.id,
                        player_points: player.points,
                        player_towns_count: player.towns,
                        alliance_id: player.alliance_id,
                        alliance_name: player.alliance_name,
                        alliance_members: player.alliance_members,
                        player_off_points: player.off_points,
                        player_def_points: player.def_points,
                    };
                }).filter(c => c !== null);

                return mergedCities;

            } catch (error) {
                console.error("Erreur lors du chargement des donnÃ©es Grepolis:", error);
                throw new Error("Erreur de chargement des donnÃ©es. Assurez-vous que les fichiers towns.txt, players.txt et alliances.txt sont prÃ©sents Ã  la racine.");
            }
        };


        // --- Composant Principal de la Carte ---

        const GrepolisMap = () => {
            const [cities, setCities] = useState([]);
            const [loading, setLoading] = useState(true);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [search, setSearch] = useState('');
            const [playerSearch, setPlayerSearch] = useState(''); 
            const [selectedOcean, setSelectedOcean] = useState('all');
            const [hoveredCity, setHoveredCity] = useState(null);
            const [selectedCity, setSelectedCity] = useState(null);
            const [distanceMode, setDistanceMode] = useState(false);
            const [citiesForDistance, setCitiesForDistance] = useState([]);
            const [dataError, setDataError] = useState(null);
            
            // 1. CrÃ©ation de la rÃ©fÃ©rence pour la zone de carte
            const mapRef = useRef(null); 

            const viewMode = 'detailed'; 
            const showSubGrid = true; 


            // Calcul des limites des villes pour le zoom automatique (inchangÃ©)
            const mapBounds = useMemo(() => {
                const targetCities = cities.filter(city => city.player_name.toLowerCase().includes(playerSearch.toLowerCase()) && city.name.toLowerCase().includes(search.toLowerCase()) && (selectedOcean === 'all' || city.ocean === selectedOcean));
                
                if (targetCities.length === 0) return { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                
                const xs = targetCities.map(c => c.x);
                const ys = targetCities.map(c => c.y);
                // Ajout d'une marge de 50 pour une meilleure visualisation
                const minX = Math.max(0, Math.min(...xs) - 50);
                const maxX = Math.min(1000, Math.max(...xs) + 50);
                const minY = Math.max(0, Math.min(...ys) - 50);
                const maxY = Math.min(1000, Math.max(...ys) + 50);
                return { minX, maxX, minY, maxY };
            }, [cities, search, playerSearch, selectedOcean]);


            // Zoom automatique sur les zones occupÃ©es (inchangÃ©)
            const zoomToOccupiedAreas = useCallback((bounds = mapBounds) => {
                if (cities.length === 0) return;
                
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                const mapWidth = 800; // Taille arbitraire d'affichage
                const mapHeight = 600;

                const scaleX = mapWidth / width; 
                const scaleY = mapHeight / height; 
                const scale = Math.min(scaleX, scaleY, 10); // Limiter le zoom max

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                
                // Centrer la nouvelle zone dans l'Ã©cran de la carte (taille 1000x1000)
                setTransform({
                    x: (1000 / 2) - centerX * scale, 
                    y: (1000 / 2) - centerY * scale, 
                    scale: scale
                });
            }, [cities.length, mapBounds]);


            // Gestion du zoom (Molette) - Mise Ã  jour pour `useCallback` (inchangÃ©)
            const handleWheel = useCallback((e) => {
                e.preventDefault(); // <-- Ceci est maintenant OK car l'Ã©couteur n'est plus "passif"
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                setTransform(prev => ({ 
                    ...prev, 
                    scale: Math.max(0.1, Math.min(10, prev.scale * scale)) 
                }));
            }, []);
            
            // 2. Utilisation de `useEffect` pour attacher l'Ã©couteur `wheel` non passif
            useEffect(() => {
                const mapElement = mapRef.current;
                if (mapElement) {
                    // Ajout de l'Ã©couteur d'Ã©vÃ©nement natif avec { passive: false }
                    mapElement.addEventListener('wheel', handleWheel, { passive: false });
                    
                    // Fonction de nettoyage pour retirer l'Ã©couteur lorsque le composant se dÃ©monte
                    return () => {
                        mapElement.removeEventListener('wheel', handleWheel);
                    };
                }
            }, [handleWheel]); // DÃ©pendance Ã  handleWheel (qui est `useCallback`Ã©)


            // Le reste du code React reste inchangÃ©, car le problÃ¨me se situait
            // uniquement dans la gestion de l'Ã©vÃ©nement `wheel`.


            // Chargement des donnÃ©es au montage du composant (inchangÃ©)
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const data = await fetchData();
                        setCities(data);
                        // Zoom initial aprÃ¨s chargement sur toute la carte
                        const initialBounds = { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                        zoomToOccupiedAreas(initialBounds); 
                    } catch (err) {
                        setDataError(err.message);
                    } finally {
                        setLoading(false);
                    }
                };
                loadData();
            }, []);
            
            // NOUVEL EFFET: Appliquer le zoom aprÃ¨s le filtrage (inchangÃ©)
            useEffect(() => {
                // S'assurer que le zoom ne se produit qu'aprÃ¨s le chargement initial
                if (!loading && cities.length > 0) {
                    zoomToOccupiedAreas(mapBounds);
                }
            }, [search, playerSearch, selectedOcean, loading, cities.length, zoomToOccupiedAreas, mapBounds]);
            

            // Logique de filtrage (inchangÃ©)
            const filteredCities = useMemo(() => {
                const lowerCaseSearch = search.toLowerCase();
                const lowerCasePlayerSearch = playerSearch.toLowerCase(); 

                return cities.filter(city => {
                    const matchTown = city.name.toLowerCase().includes(lowerCaseSearch); 
                    const matchPlayer = city.player_name.toLowerCase().includes(lowerCasePlayerSearch); 

                    const matchOcean = selectedOcean === 'all' || city.ocean === selectedOcean;
                    return matchTown && matchPlayer && matchOcean;
                });
            }, [cities, search, playerSearch, selectedOcean]);

            // Groupement des villes par coordonnÃ©es (inchangÃ©)
            const groupedCities = useMemo(() => {
                const groups = {};
                filteredCities.forEach(city => {
                    const key = `${city.x},${city.y}`;
                    if (!groups[key]) {
                        groups[key] = [];
                    }
                    groups[key].push(city);
                });
                return groups;
            }, [filteredCities]);

            // OcÃ©ans disponibles (pour le filtre, inchangÃ©)
            const oceans = useMemo(() => {
                return ['all', ...new Set(cities.map(c => c.ocean))].sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return parseInt(a) - parseInt(b);
                });
            }, [cities]);

            // Couleurs par ocÃ©an (inchangÃ©)
            const oceanColors = { 
                '02': '#3b82f6', '05': '#8b5cf6', '06': '#ec4899', '13': '#f59e0b', 
                '14': '#10b981', '15': '#06b6d4', '16': '#ef4444', '24': '#a855f7', 
                '25': '#14b8a6', '34': '#f97316' 
            }; 

            // Gestion du dÃ©placement (Mouse) - inchangÃ©
            const handleMouseDown = useCallback((e) => {
                setIsDragging(true);
                setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
            }, [transform]);

            const handleMouseMove = useCallback((e) => {
                if (!isDragging) return;
                setTransform(prev => ({
                    ...prev,
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                }));
            }, [isDragging, dragStart]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);
            
            const handleCityClick = useCallback((city) => {
                if (distanceMode) {
                    setCitiesForDistance(prev => {
                        if (prev.length === 0) {
                            return [city];
                        } else if (prev.length === 1) {
                            if (prev[0].id === city.id) return []; // Deselect
                            return [...prev, city];
                        } else {
                            return [city];
                        }
                    });
                } else {
                    setSelectedCity(prev => (prev && prev.id === city.id ? null : city));
                }
            }, [distanceMode]);

            const resetDistanceMode = useCallback(() => {
                setDistanceMode(false);
                setCitiesForDistance([]);
            }, []);
            
            // Rendu des carrÃ©s d'ocÃ©an (inchangÃ©)
            const renderOceanSquares = useCallback(() => {
                const oceanSquares = [];
                for (let x = 0; x < 10; x++) {
                    for (let y = 0; y < 10; y++) {
                        // Utilise la fonction corrigÃ©e pour obtenir l'ID d'ocÃ©an Ã  2 chiffres (ex: "24")
                        const grepolisOceanNum = getGrepolisOcean(x * 100 + 1, y * 100 + 1); 
                        const isOccupied = cities.some(city => city.ocean === grepolisOceanNum);
                        const oceanX = x;
                        const oceanY = y;
                        const isEven = (oceanX % 2 === 0) === (oceanY % 2 === 0); 
                        
                        if (viewMode === 'detailed' || isOccupied) { 
                            oceanSquares.push(
                                <g key={grepolisOceanNum}>
                                    <rect 
                                        x={oceanX * 100} y={oceanY * 100} 
                                        width={100} height={100} 
                                        fill={isEven ? '#1e3a5f' : '#2d4a6f'} 
                                        stroke="#0f172a" strokeWidth="0.5" 
                                        opacity={isOccupied ? 1 : 0.3} 
                                    />
                                    <text 
                                        x={oceanX * 100 + 50} y={oceanY * 100 + 50} 
                                        textAnchor="middle" dy="0.35em" 
                                        fill={isOccupied ? '#fbbf24' : '#64748b'} 
                                        fontSize="12" fontWeight="bold" 
                                        opacity={isOccupied ? 0.9 : 0.3} 
                                    >
                                        {grepolisOceanNum} 
                                    </text>
                                </g>
                            );
                        }
                    }
                }
                return oceanSquares;
            }, [cities]);
            
            // Rendu de la grille secondaire 5x5 (inchangÃ©)
            const renderSubGrid = useCallback(() => {
                if (!showSubGrid) return null; 

                const subGridLines = [];
                for (let x = 0; x <= 1000; x += 20) {
                    subGridLines.push(
                        <line key={`vline-${x}`} x1={x} y1={0} x2={x} y2={1000} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                for (let y = 0; y <= 1000; y += 20) {
                    subGridLines.push(
                        <line key={`hline-${y}`} x1={0} y1={y} x2={1000} y2={y} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                return subGridLines;
            }, []);

            // Rendu des lignes de distance (inchangÃ©)
            const renderDistanceLines = useCallback(() => {
                if (citiesForDistance.length < 2) return null;
                const [city1, city2] = citiesForDistance;
                const distance = calculateDistance(city1.x, city1.y, city2.x, city2.y);
                return (
                    <g>
                        <line x1={city1.x} y1={city1.y} x2={city2.x} y2={city2.y} 
                            stroke="#10b981" strokeWidth="1.5" className="distance-line" />
                        
                        <text 
                            x={(city1.x + city2.x) / 2} y={(city1.y + city2.y) / 2} 
                            textAnchor="middle" dy="-0.5em" 
                            fill="#10b981" fontSize={Math.max(4, 14 / transform.scale)} 
                            fontWeight="bold" 
                            style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                        >
                            {distance}
                        </text>
                    </g>
                );
            }, [citiesForDistance, transform.scale]);

            // Rendu des villes (inchangÃ©)
            const renderCities = useMemo(() => {
                return Object.entries(groupedCities).map(([key, citiesAtLocation]) => {
                    const [x, y] = key.split(',').map(Number);
                    const city = citiesAtLocation[0]; 
                    const oceanColor = oceanColors[city.ocean] || '#ccc'; 
                    const isHovered = hoveredCity && hoveredCity.x === x && hoveredCity.y === y;
                    const isSelected = selectedCity && selectedCity.x === x && selectedCity.y === y;
                    const isInDistanceSelection = citiesForDistance.some(c => c.x === x && c.y === y);

                    return (
                        <g key={key}>
                            {/* Cercle principal de la ville/cluster */}
                            <circle 
                                cx={x} cy={y} 
                                r={Math.max(1, 4 / transform.scale)} 
                                fill={oceanColor} 
                                stroke={isInDistanceSelection ? '#10b981' : (isSelected ? '#fff' : isHovered ? '#fff' : oceanColor)} 
                                strokeWidth={isInDistanceSelection ? 2 : (isSelected ? 1.5 : isHovered ? 1 : 0)}
                                opacity={isInDistanceSelection ? 1 : (isHovered || isSelected ? 1 : 0.9)}
                                onMouseEnter={() => setHoveredCity(citiesAtLocation[0])}
                                onMouseLeave={() => setHoveredCity(null)}
                                onClick={() => handleCityClick(citiesAtLocation[0])}
                                style={{ cursor: 'pointer' }}
                            />
                            {/* Indicateur de nombre pour les clusters */}
                            {citiesAtLocation.length > 1 && (
                                <text 
                                    x={x} y={y} 
                                    textAnchor="middle" dy="0.3em" 
                                    fill="white" 
                                    fontSize={Math.max(3, 8 / transform.scale)} 
                                    fontWeight="bold" 
                                    style={{ pointerEvents: 'none' }}
                                >
                                    {citiesAtLocation.length}
                                </text>
                            )}
                            {/* Tooltip au survol/sÃ©lection */}
                            {(isHovered || isSelected) && !distanceMode && transform.scale > 0.5 && (
                                <>
                                    <text 
                                        x={x} y={y - 8 - (10 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#fbbf24" 
                                        fontSize={Math.max(4, 12 / transform.scale)} 
                                        fontWeight="bold" 
                                        style={{ pointerEvents: 'none' }}
                                    >
                                        {citiesAtLocation[0].name}
                                    </text>
                                    <text 
                                        x={x} y={y - 4 - (5 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#94a3b8" 
                                        fontSize={Math.max(3, 10 / transform.scale)} 
                                        style={{ pointerEvents: 'none' }}
                                    >
                                        ({x}, {y}) - {citiesAtLocation[0].player_name}
                                    </text>
                                </>
                            )}
                        </g>
                    );
                });
            }, [groupedCities, hoveredCity, selectedCity, citiesForDistance, oceanColors, distanceMode, handleCityClick, transform.scale]);
            
            // Composant de l'en-tÃªte (inchangÃ©)
            const renderHeader = () => (
                <div className="bg-slate-800 p-4 shadow-lg">
                    <h1 className="text-2xl font-bold text-amber-400 mb-4 flex items-center gap-2">
                         <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0l-4.243-4.243m10.606 0a2 2 0 110-2 2 2 0 010 2zm-10.606 0a2 2 0 110-2 2 2 0 010 2zM6 10h2m4 0h2m4 0h2m-10 0V4h12v6" />
                        </svg>
                        Carte des Villes de l'Alliance
                    </h1>
                    
                    <div className="flex flex-wrap items-center gap-3">
                        {/* Rechercher une ville */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="ðŸ” Rechercher une ville..."
                                value={search}
                                onChange={(e) => setSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-60 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                        </div>

                        {/* Rechercher un joueur */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="ðŸ‘¤ Rechercher un joueur..."
                                value={playerSearch}
                                onChange={(e) => setPlayerSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-60 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14c3.486 0 5.122 1.981 5.64 3.55
