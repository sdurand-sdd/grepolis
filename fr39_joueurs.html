<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Villes Grepolis</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        .map-container { cursor: grab; }
        .map-container:active { cursor: grabbing; }
        .distance-line { stroke-dasharray: 5,5; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -10; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect } = React;

        // --- Fonctions de base et de parsing (hors composant) ---

        // Calcul de la distance Grepolis entre deux coordonnées (x, y)
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)).toFixed(2);
        };

        /**
         * FIX 1: Calcul de l'océan Grepolis (format XXYY)
         * Garantit le format 00 à 99.
         */
        const getGrepolisOcean = (x, y) => {
            const oceanX = Math.floor(x / 100).toString().padStart(2, '0');
            const oceanY = Math.floor(y / 100).toString().padStart(2, '0');
            return oceanX + oceanY;
        };
        
        // Fonction générique pour parser les fichiers TXT (supposés être CSV)
        const parseData = (text, headers) => {
            const lines = text.trim().split('\n').filter(line => line.trim() !== '' && !line.startsWith('#'));
            if (lines.length === 0) return [];
            
            return lines.map(line => {
                // Utilisation de la virgule (,) comme délimiteur
                const values = line.split(','); 
                const obj = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    // Tente de convertir en nombre si ce n'est pas un nom
                    obj[header] = (header.endsWith('_id') || ['id', 'x', 'y', 'points', 'towns', 'members', 'rank', 'off_rank', 'off_points', 'def_rank', 'def_points'].includes(header)) ? (Number(value) || 0) : value;
                });
                return obj;
            }).filter(obj => Object.keys(obj).length === headers.length);
        };

        // Fonction pour charger et fusionner toutes les données
        const fetchData = async () => {
            const BASE_URL = ''; // Fichiers dans le même dossier que l'HTML

            try {
                const [alliancesRes, playersRes, townsRes] = await Promise.all([
                    fetch(`${BASE_URL}alliances.txt`),
                    fetch(`${BASE_URL}players.txt`),
                    fetch(`${BASE_URL}towns.txt`),
                ]);

                // Vérification des erreurs de chargement
                if (!alliancesRes.ok || !playersRes.ok || !townsRes.ok) {
                    throw new Error("Erreur de chargement d'un des fichiers TXT.");
                }

                const [alliancesText, playersText, townsText] = await Promise.all([
                    alliancesRes.text(),
                    playersRes.text(),
                    townsRes.text(),
                ]);

                // En-têtes Grepolis typiques (ajustez si vos fichiers sont différents)
                const alliancesHeaders = ['id', 'name', 'points', 'towns', 'members'];
                const playersHeaders = ['id', 'name', 'alliance_id', 'points', 'rank', 'towns', 'off_rank', 'off_points', 'def_rank', 'def_points'];
                const townsHeaders = ['id', 'player_id', 'name', 'x', 'y', 'points', 'type']; 

                const alliances = parseData(alliancesText, alliancesHeaders);
                const players = parseData(playersText, playersHeaders);
                const towns = parseData(townsText, townsHeaders);

                // Mapping pour un accès rapide
                const allianceMap = new Map(alliances.map(a => [a.id, a]));
                const playerMap = new Map(players.map(p => [p.id, {
                    ...p,
                    alliance_name: allianceMap.get(p.alliance_id)?.name || 'Sans alliance',
                    alliance_members: allianceMap.get(p.alliance_id)?.members || 0
                }]));

                // Fusion des données : Création de la liste de villes enrichie
                const mergedCities = towns.map(town => {
                    const player = playerMap.get(town.player_id);
                    if (!player || town.points === 0) return null; // Ignore les villes sans joueur ou barbares (points=0)

                    return {
                        ...town,
                        ocean: getGrepolisOcean(town.x, town.y), // Calcul de l'océan corrigé
                        player_name: player.name,
                        player_id: player.id,
                        player_points: player.points,
                        player_towns_count: player.towns,
                        alliance_id: player.alliance_id,
                        alliance_name: player.alliance_name,
                        alliance_members: player.alliance_members,
                        player_off_points: player.off_points,
                        player_def_points: player.def_points,
                    };
                }).filter(c => c !== null);

                return mergedCities;

            } catch (error) {
                console.error("Erreur lors du chargement des données Grepolis:", error);
                throw new Error("Erreur de chargement des données. Assurez-vous que les fichiers towns.txt, players.txt et alliances.txt sont présents à la racine.");
            }
        };


        // --- Composant Principal de la Carte ---

        const GrepolisMap = () => {
            const [cities, setCities] = useState([]);
            const [loading, setLoading] = useState(true);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [search, setSearch] = useState('');
            const [playerSearch, setPlayerSearch] = useState(''); 
            const [selectedOcean, setSelectedOcean] = useState('all');
            const [hoveredCity, setHoveredCity] = useState(null);
            const [selectedCity, setSelectedCity] = useState(null);
            const [distanceMode, setDistanceMode] = useState(false);
            const [citiesForDistance, setCitiesForDistance] = useState([]);
            const [dataError, setDataError] = useState(null);

            const viewMode = 'detailed'; 
            const showSubGrid = true; 


            // Calcul des limites des villes pour le zoom automatique
            const mapBounds = useMemo(() => {
                const targetCities = cities.filter(city => city.player_name.toLowerCase().includes(playerSearch.toLowerCase()) && city.name.toLowerCase().includes(search.toLowerCase()) && (selectedOcean === 'all' || city.ocean === selectedOcean));
                
                if (targetCities.length === 0) return { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                
                const xs = targetCities.map(c => c.x);
                const ys = targetCities.map(c => c.y);
                // Ajout d'une marge de 50 pour une meilleure visualisation
                const minX = Math.max(0, Math.min(...xs) - 50);
                const maxX = Math.min(1000, Math.max(...xs) + 50);
                const minY = Math.max(0, Math.min(...ys) - 50);
                const maxY = Math.min(1000, Math.max(...ys) + 50);
                return { minX, maxX, minY, maxY };
            }, [cities, search, playerSearch, selectedOcean]);


            /**
             * FIX 2: Zoom automatique sur les zones occupées (appelé après le filtre)
             */
            const zoomToOccupiedAreas = useCallback((bounds = mapBounds) => {
                if (cities.length === 0) return;
                
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                const mapWidth = 800; // Taille arbitraire d'affichage
                const mapHeight = 600;

                const scaleX = mapWidth / width; 
                const scaleY = mapHeight / height; 
                const scale = Math.min(scaleX, scaleY, 10); // Limiter le zoom max

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                
                // Centrer la nouvelle zone dans l'écran de la carte (taille 1000x1000)
                setTransform({
                    x: (1000 / 2) - centerX * scale, 
                    y: (1000 / 2) - centerY * scale, 
                    scale: scale
                });
            }, [cities.length, mapBounds]);


            // Chargement des données au montage du composant
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const data = await fetchData();
                        setCities(data);
                        // Zoom initial après chargement sur toute la carte
                        const initialBounds = { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                        zoomToOccupiedAreas(initialBounds); 
                    } catch (err) {
                        setDataError(err.message);
                    } finally {
                        setLoading(false);
                    }
                };
                loadData();
            }, []);
            
            // NOUVEL EFFET: Appliquer le zoom après le filtrage (pour désactiver le clustering sur la zone filtrée)
            useEffect(() => {
                // S'assurer que le zoom ne se produit qu'après le chargement initial
                if (!loading && cities.length > 0) {
                    zoomToOccupiedAreas(mapBounds);
                }
            }, [search, playerSearch, selectedOcean, loading, cities.length, zoomToOccupiedAreas, mapBounds]);
            

            // Logique de filtrage (inchangé)
            const filteredCities = useMemo(() => {
                const lowerCaseSearch = search.toLowerCase();
                const lowerCasePlayerSearch = playerSearch.toLowerCase(); 

                return cities.filter(city => {
                    const matchTown = city.name.toLowerCase().includes(lowerCaseSearch); 
                    const matchPlayer = city.player_name.toLowerCase().includes(lowerCasePlayerSearch); 

                    const matchOcean = selectedOcean === 'all' || city.ocean === selectedOcean;
                    return matchTown && matchPlayer && matchOcean;
                });
            }, [cities, search, playerSearch, selectedOcean]);

            // Groupement des villes par coordonnées (inchangé)
            const groupedCities = useMemo(() => {
                const groups = {};
                filteredCities.forEach(city => {
                    const key = `${city.x},${city.y}`;
                    if (!groups[key]) {
                        groups[key] = [];
                    }
                    groups[key].push(city);
                });
                return groups;
            }, [filteredCities]);

            // Océans disponibles (pour le filtre, inchangé)
            const oceans = useMemo(() => {
                return ['all', ...new Set(cities.map(c => c.ocean))].sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return parseInt(a) - parseInt(b);
                });
            }, [cities]);

            // Couleurs par océan (conservées de l'original)
            const oceanColors = { 
                '02': '#3b82f6', '05': '#8b5cf6', '06': '#ec4899', '13': '#f59e0b', 
                '14': '#10b981', '15': '#06b6d4', '16': '#ef4444', '24': '#a855f7', 
                '25': '#14b8a6', '34': '#f97316' 
            }; 

            // Gestion du zoom et du déplacement (inchangé)
            const handleWheel = useCallback((e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                setTransform(prev => ({ 
                    ...prev, 
                    scale: Math.max(0.1, Math.min(10, prev.scale * scale)) 
                }));
            }, []);

            const handleMouseDown = useCallback((e) => {
                setIsDragging(true);
                setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
            }, [transform]);

            const handleMouseMove = useCallback((e) => {
                if (!isDragging) return;
                setTransform(prev => ({
                    ...prev,
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                }));
            }, [isDragging, dragStart]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);
            
            const handleCityClick = useCallback((city) => {
                if (distanceMode) {
                    setCitiesForDistance(prev => {
                        if (prev.length === 0) {
                            return [city];
                        } else if (prev.length === 1) {
                            if (prev[0].id === city.id) return []; // Deselect
                            return [...prev, city];
                        } else {
                            return [city];
                        }
                    });
                } else {
                    setSelectedCity(prev => (prev && prev.id === city.id ? null : city));
                }
            }, [distanceMode]);

            const resetDistanceMode = useCallback(() => {
                setDistanceMode(false);
                setCitiesForDistance([]);
            }, []);
            
            // Rendu des carrés d'océan
            const renderOceanSquares = useCallback(() => {
                const oceanSquares = [];
                for (let x = 0; x < 10; x++) {
                    for (let y = 0; y < 10; y++) {
                        // Utilisation de coordonnées pour le calcul de l'océan (ex: 100*0 + 1, 100*0 + 1 -> 00)
                        const grepolisOceanNum = getGrepolisOcean(x * 100 + 1, y * 100 + 1); 
                        const isOccupied = cities.some(city => city.ocean === grepolisOceanNum);
                        const oceanX = x;
                        const oceanY = y;
                        const isEven = (oceanX % 2 === 0) === (oceanY % 2 === 0); 
                        
                        if (viewMode === 'detailed' || isOccupied) { 
                            oceanSquares.push(
                                <g key={grepolisOceanNum}>
                                    <rect 
                                        x={oceanX * 100} y={oceanY * 100} 
                                        width={100} height={100} 
                                        fill={isEven ? '#1e3a5f' : '#2d4a6f'} 
                                        stroke="#0f172a" strokeWidth="0.5" 
                                        opacity={isOccupied ? 1 : 0.3} 
                                    />
                                    <text 
                                        x={oceanX * 100 + 50} y={oceanY * 100 + 50} 
                                        textAnchor="middle" dy="0.35em" 
                                        fill={isOccupied ? '#fbbf24' : '#64748b'} 
                                        fontSize="12" fontWeight="bold" 
                                        opacity={isOccupied ? 0.9 : 0.3} 
                                    >
                                        {grepolisOceanNum}
                                    </text>
                                </g>
                            );
                        }
                    }
                }
                return oceanSquares;
            }, [cities]);
            
            // Rendu de la grille secondaire 5x5 (inchangé)
            const renderSubGrid = useCallback(() => {
                if (!showSubGrid) return null; 

                const subGridLines = [];
                for (let x = 0; x <= 1000; x += 20) {
                    subGridLines.push(
                        <line key={`vline-${x}`} x1={x} y1={0} x2={x} y2={1000} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                for (let y = 0; y <= 1000; y += 20) {
                    subGridLines.push(
                        <line key={`hline-${y}`} x1={0} y1={y} x2={1000} y2={y} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                return subGridLines;
            }, []);

            // Rendu des lignes de distance (inchangé)
            const renderDistanceLines = useCallback(() => {
                if (citiesForDistance.length < 2) return null;
                const [city1, city2] = citiesForDistance;
                const distance = calculateDistance(city1.x, city1.y, city2.x, city2.y);
                return (
                    <g>
                        <line x1={city1.x} y1={city1.y} x2={city2.x} y2={city2.y} 
                            stroke="#10b981" strokeWidth="1.5" className="distance-line" />
                        
                        <text 
                            x={(city1.x + city2.x) / 2} y={(city1.y + city2.y) / 2} 
                            textAnchor="middle" dy="-0.5em" 
                            fill="#10b981" fontSize={Math.max(4, 14 / transform.scale)} 
                            fontWeight="bold" 
                            style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                        >
                            {distance}
                        </text>
                    </g>
                );
            }, [citiesForDistance, transform.scale]);

            // Rendu des villes 
            const renderCities = useMemo(() => {
                return Object.entries(groupedCities).map(([key
