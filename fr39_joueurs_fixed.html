<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Villes Grepolis</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        .map-container { 
            cursor: grab; 
            /* Emp√™che le d√©filement de la page sur les gestes tactiles */
            touch-action: none; 
        }
        .map-container:active { cursor: grabbing; }
        .distance-line { stroke-dasharray: 5,5; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -10; } }

        /* Correction pour les mobiles : la carte doit prendre une hauteur minimale pour √™tre visible */
        .map-wrapper { 
            height: 100%; 
            min-height: 35vh; /* Assure une hauteur minimale de la carte sur mobile */
        }

        /* Ajustement de la hauteur de la barre lat√©rale sur mobile pour √©viter qu'elle ne prenne tout l'√©cran */
        @media (max-width: 767px) { 
            .sidebar {
                max-height: 55vh; /* Limite la hauteur de la sidebar */
                width: 100%; 
            }
            /* Pour que le conteneur principal puisse d√©filer verticalement sur mobile */
            .main-content {
                 overflow-y: auto;
                 display: flex;
                 flex-direction: column;
            }
            .map-wrapper {
                 /* Garantit que la carte prend toute la largeur sur mobile */
                 width: 100%; 
            }
        }
    </style>
</head>
<body>
    <div id="root" class="main-content h-screen"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, useRef } = React;

        // --- Fonctions de base et de parsing (hors composant) ---

        // Calcul de la distance Grepolis entre deux coordonn√©es (x, y)
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)).toFixed(2);
        };

        // Retourne le format 2 chiffres (XY) pour l'affichage (ex: "24" pour Oc√©an 24).
        const getGrepolisOcean = (x, y) => {
            const oceanX = Math.floor(x / 100).toString(); 
            const oceanY = Math.floor(y / 100).toString();
            return oceanX.padStart(1, '0') + oceanY.padStart(1, '0'); 
        };
        
        // D√©coder les noms encod√©s en URL (accents, espaces encod√©s en + ou %20, etc.)
        const decodeName = (str) => {
            if (!str) return str;
            try {
                return decodeURIComponent(str.trim().replace(/\+/g, ' '));
            } catch (e) {
                return str.trim().replace(/\+/g, ' ');
            }
        };

        // Fonction g√©n√©rique pour parser les fichiers TXT (suppos√©s √™tre CSV)
        const parseData = (text, headers) => {
            const lines = text.trim().split('\n').filter(line => line.trim() !== '' && !line.startsWith('#'));
            if (lines.length === 0) return [];
            
            return lines.map(line => {
                const values = line.split(','); 
                const obj = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    const isNumeric = (header.endsWith('_id') || ['id', 'x', 'y', 'points', 'island_pos', 'towns', 'members', 'rank', 'off_rank', 'off_points', 'def_rank', 'def_points'].includes(header));
                    obj[header] = isNumeric ? (Number(value) || 0) : decodeName(value);
                });
                if (Object.keys(obj).length !== headers.length) {
                    return null;
                }
                return obj;
            }).filter(obj => obj !== null);
        };

        // Fonction pour charger et fusionner toutes les donn√©es
        const fetchData = async () => {
            const BASE_URL = ''; // Fichiers dans le m√™me dossier que l'HTML

            try {
                const [alliancesRes, playersRes, townsRes, updateRes] = await Promise.all([
                    fetch(`${BASE_URL}alliances.txt`),
                    fetch(`${BASE_URL}players.txt`),
                    fetch(`${BASE_URL}towns.txt`),
                    fetch(`${BASE_URL}last_update.txt`),
                ]);

                if (!alliancesRes.ok || !playersRes.ok || !townsRes.ok) {
                    throw new Error("Erreur de chargement d'un des fichiers TXT (alliances, players, ou towns).");
                }

                const [alliancesText, playersText, townsText, updateText] = await Promise.all([
                    alliancesRes.text(),
                    playersRes.text(),
                    townsRes.text(),
                    updateRes.ok ? updateRes.text() : 'Date inconnue',
                ]);

                const alliancesHeaders = ['id', 'name', 'points', 'towns', 'members'];
                const playersHeaders = ['id', 'name', 'alliance_id', 'points', 'rank', 'towns', 'off_rank', 'off_points', 'def_rank', 'def_points'];
                const townsHeaders = ['id', 'player_id', 'name', 'x', 'y', 'island_pos', 'points']; 

                const alliances = parseData(alliancesText, alliancesHeaders);
                const players = parseData(playersText, playersHeaders);
                const towns = parseData(townsText, townsHeaders);
                
                const lastUpdate = updateText.trim().split('\n')[0];

                const allianceMap = new Map(alliances.map(a => [a.id, a]));
                const playerMap = new Map(players.map(p => [p.id, {
                    ...p,
                    alliance_name: allianceMap.get(p.alliance_id)?.name || 'Sans alliance',
                    alliance_members: allianceMap.get(p.alliance_id)?.members || 0
                }]));

                const mergedCities = towns.map(town => {
                    const player = playerMap.get(town.player_id);
                    if (!player || town.points === 0) return null; 

                    return {
                        ...town,
                        ocean: getGrepolisOcean(town.x, town.y), 
                        player_name: player.name,
                        player_id: player.id,
                        player_points: player.points,
                        player_towns_count: player.towns,
                        alliance_id: player.alliance_id,
                        alliance_name: player.alliance_name,
                        alliance_members: player.alliance_members,
                        player_off_points: player.off_points,
                        player_def_points: player.def_points,
                    };
                }).filter(c => c !== null);

                return { mergedCities, alliances, lastUpdate };

            } catch (error) {
                console.error("Erreur lors du chargement des donn√©es Grepolis:", error);
                throw new Error("Erreur de chargement des donn√©es. Assurez-vous que les fichiers towns.txt, players.txt et alliances.txt sont pr√©sents √† la racine et dans le bon format.");
            }
        };

        const generateColor = (id) => {
            const num = parseInt(id, 10);
            const hue = (num * 6) % 360; 
            const saturation = 70; 
            const lightness = 60; 
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };

        const generateOceanColors = () => {
            const colors = {};
            for (let i = 0; i < 100; i++) {
                const id = i.toString().padStart(2, '0');
                colors[id] = generateColor(i);
            }
            return colors;
        };

        const generateAllianceColors = (alliances) => {
            const colors = {};
            alliances.forEach(alliance => {
                const hueSeed = Math.abs(alliance.id * 13) % 360; 
                colors[alliance.id] = `hsl(${hueSeed}, 80%, 55%)`; 
            });
            colors[0] = '#94a3b8'; // Gris-bleu pour "Sans Alliance"
            return colors;
        };


        // --- Composant Principal de la Carte ---

        const GrepolisMap = () => {
            const [cities, setCities] = useState([]);
            const [alliances, setAlliances] = useState([]); 
            const [lastUpdate, setLastUpdate] = useState(null);
            const [loading, setLoading] = useState(true);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            // Nouvelle variable d'√©tat pour le zoom √† deux doigts
            const [initialPinchDistance, setInitialPinchDistance] = useState(null); 
            const [initialScale, setInitialScale] = useState(1);
            
            const [search, setSearch] = useState('');
            const [playerSearch, setPlayerSearch] = useState(''); 
            const [selectedOcean, setSelectedOcean] = useState('all');
            const [hoveredCity, setHoveredCity] = useState(null);
            const [selectedCity, setSelectedCity] = useState(null);
            const [distanceMode, setDistanceMode] = useState(false);
            const [citiesForDistance, setCitiesForDistance] = useState([]);
            const [dataError, setDataError] = useState(null);
            const [colorMode, setColorMode] = useState('alliance'); 
            
            const mapRef = useRef(null); 

            const viewMode = 'detailed'; 
            const showSubGrid = true; 

            const oceanColors = useMemo(generateOceanColors, []);
            const allianceColors = useMemo(() => generateAllianceColors(alliances), [alliances]);

            const mapBounds = useMemo(() => {
                const targetCities = cities.filter(city => city.player_name.toLowerCase().includes(playerSearch.toLowerCase()) && city.name.toLowerCase().includes(search.toLowerCase()) && (selectedOcean === 'all' || city.ocean === selectedOcean));
                
                if (targetCities.length === 0) return { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
                
                const xs = targetCities.map(c => c.x);
                const ys = targetCities.map(c => c.y);
                const minX = Math.max(0, Math.min(...xs) - 50);
                const maxX = Math.min(1000, Math.max(...xs) + 50);
                const minY = Math.max(0, Math.min(...ys) - 50);
                const maxY = Math.min(1000, Math.max(...ys) + 50);
                return { minX, maxX, minY, maxY };
            }, [cities, search, playerSearch, selectedOcean]);


            const zoomToOccupiedAreas = useCallback((bounds = mapBounds) => {
                if (cities.length === 0 || !mapRef.current) return;
                
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                const mapContainer = mapRef.current.closest('.map-wrapper');
                if (!mapContainer) return;

                const mapWidth = mapContainer.offsetWidth; 
                const mapHeight = mapContainer.offsetHeight;

                const scaleX = mapWidth / width; 
                const scaleY = mapHeight / height; 
                const scale = Math.min(scaleX, scaleY, 10); 

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                
                const newX = (mapWidth / 2) - centerX * scale;
                const newY = (mapHeight / 2) - centerY * scale;

                setTransform({ x: newX, y: newY, scale: scale });
            }, [cities.length, mapBounds]);


            // Gestion du zoom (Molette) 
            const handleWheel = useCallback((e) => {
                e.preventDefault(); 
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                
                const mapRect = mapRef.current.getBoundingClientRect();
                const mouseX = e.clientX - mapRect.left;
                const mouseY = e.clientY - mapRect.top;
                
                setTransform(prev => {
                    const newScale = Math.max(0.1, Math.min(10, prev.scale * scaleFactor));
                    
                    if (newScale === prev.scale) return prev;

                    const x = mouseX - (mouseX - prev.x) * (scaleFactor);
                    const y = mouseY - (mouseY - prev.y) * (scaleFactor);

                    return { x, y, scale: newScale };
                });
            }, []);
            
            useEffect(() => {
                const mapElement = mapRef.current;
                if (mapElement) {
                    mapElement.addEventListener('wheel', handleWheel, { passive: false });
                    
                    return () => {
                        mapElement.removeEventListener('wheel', handleWheel);
                    };
                }
            }, [handleWheel]); 

            // ... (useEffect, fetch, useMemo pour cities, oceans...)
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const { mergedCities, alliances, lastUpdate } = await fetchData();
                        setCities(mergedCities);
                        setAlliances(alliances);
                        setLastUpdate(lastUpdate);
                    } catch (err) {
                        setDataError(err.message);
                    } finally {
                        setLoading(false);
                    }
                };
                loadData();
            }, []);
            
            useEffect(() => {
                if (!loading && cities.length > 0) {
                    zoomToOccupiedAreas(mapBounds);
                }
                
                window.addEventListener('resize', zoomToOccupiedAreas);
                return () => window.removeEventListener('resize', zoomToOccupiedAreas);

            }, [search, playerSearch, selectedOcean, loading, cities.length, zoomToOccupiedAreas, mapBounds]);

            const filteredCities = useMemo(() => {
                const lowerCaseSearch = search.toLowerCase();
                const lowerCasePlayerSearch = playerSearch.toLowerCase(); 

                return cities.filter(city => {
                    const matchTown = city.name.toLowerCase().includes(lowerCaseSearch); 
                    const matchPlayer = city.player_name.toLowerCase().includes(lowerCasePlayerSearch); 
                    const matchOcean = selectedOcean === 'all' || city.ocean === selectedOcean;
                    return matchTown && matchPlayer && matchOcean;
                });
            }, [cities, search, playerSearch, selectedOcean]);

            const groupedCities = useMemo(() => {
                const groups = {};
                filteredCities.forEach(city => {
                    const key = `${city.x},${city.y}`;
                    if (!groups[key]) { groups[key] = []; }
                    groups[key].push(city);
                });
                return groups;
            }, [filteredCities]);

            const oceans = useMemo(() => {
                const allOceans = ['all', ...new Set(cities.map(c => c.ocean))];
                return allOceans.sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return parseInt(a) - parseInt(b);
                });
            }, [cities]);
            
            // --- GESTION DU D√âPLACEMENT SOURIS (inchang√©e) ---
            const handleMouseDown = useCallback((e) => {
                if (e.button === 2) return;
                setIsDragging(true);
                setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
            }, [transform]);

            const handleMouseMove = useCallback((e) => {
                if (!isDragging || initialPinchDistance !== null) return;
                setTransform(prev => ({
                    ...prev,
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                }));
            }, [isDragging, dragStart, initialPinchDistance]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);
            
            // --- GESTION DU D√âPLACEMENT ET ZOOM TACTILE (CORRIG√âE) ---

            const getTouchDistance = (touches) => {
                return Math.sqrt(
                    Math.pow(touches[0].clientX - touches[1].clientX, 2) +
                    Math.pow(touches[0].clientY - touches[1].clientY, 2)
                );
            };

            const handleTouchStart = useCallback((e) => {
                if (e.touches.length === 2) {
                    // D√©but du PINCEMENT (Zoom)
                    e.preventDefault(); 
                    setInitialPinchDistance(getTouchDistance(e.touches));
                    setInitialScale(transform.scale);
                    setIsDragging(false); // S'assurer que le drag simple est d√©sactiv√©
                } else if (e.touches.length === 1) {
                    // D√©but du GLISSEMENT (D√©placement)
                    setIsDragging(true);
                    setInitialPinchDistance(null); // R√©initialiser le zoom
                    setDragStart({ x: e.touches[0].clientX - transform.x, y: e.touches[0].clientY - transform.y });
                    e.preventDefault(); 
                }
            }, [transform]);

            const handleTouchMove = useCallback((e) => {
                if (e.touches.length === 2 && initialPinchDistance !== null) {
                    // Mouvement de PINCEMENT (Zoom et D√©placement)
                    e.preventDefault();
                    
                    const currentDistance = getTouchDistance(e.touches);
                    const scaleFactor = currentDistance / initialPinchDistance;
                    let newScale = Math.max(0.1, Math.min(10, initialScale * scaleFactor));
                    
                    // Calcul du centre de pincement (point d'ancrage)
                    const touchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const touchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    // Ajustement de la translation pour centrer le zoom
                    setTransform(prev => {
                        const newX = touchCenterX - (touchCenterX - prev.x) * (newScale / prev.scale);
                        const newY = touchCenterY - (touchCenterY - prev.y) * (newScale / prev.scale);
                        
                        return { 
                            x: newX,
                            y: newY,
                            scale: newScale
                        };
                    });

                } else if (e.touches.length === 1 && isDragging) {
                    // Mouvement de GLISSEMENT (D√©placement)
                    setTransform(prev => ({
                        ...prev,
                        x: e.touches[0].clientX - dragStart.x,
                        y: e.touches[0].clientY - dragStart.y
                    }));
                    e.preventDefault();
                }
            }, [isDragging, dragStart, initialPinchDistance, initialScale]);

            const handleTouchEnd = useCallback((e) => {
                setIsDragging(false);
                setInitialPinchDistance(null); // Fin du geste de zoom/glissement
            }, []);
            
            // G√®re la s√©lection d'un cluster (tableau) ou d'une ville (objet)
            const handleCityClick = useCallback((e, cityOrCluster) => {
                // Si c'√©tait un glissement (isDragging=true) ou un zoom, on n'interpr√®te pas cela comme un clic.
                // On laisse l'√©v√©nement tactile par d√©faut se propager pour le "tap" si ce n'est pas un glissement.
                if (isDragging) return; 
                
                if (distanceMode) {
                    const city = Array.isArray(cityOrCluster) ? cityOrCluster[0] : cityOrCluster;
                    setCitiesForDistance(prev => {
                        if (prev.length === 0) {
                            return [city];
                        } else if (prev.length === 1) {
                            if (prev[0].id === city.id) return []; 
                            return [...prev, city];
                        } else {
                            return [city];
                        }
                    });
                } else {
                    setSelectedCity(prev => {
                        let isSameSelection = false;
                        if (prev && cityOrCluster) {
                            if (Array.isArray(prev) && Array.isArray(cityOrCluster)) {
                                isSameSelection = prev[0].x === cityOrCluster[0].x && prev[0].y === cityOrCluster[0].y;
                            } else if (!Array.isArray(prev) && !Array.isArray(cityOrCluster)) {
                                isSameSelection = prev.id === cityOrCluster.id;
                            }
                        }
                        return isSameSelection ? null : cityOrCluster;
                    });
                }
            }, [distanceMode, isDragging]);
            
            // ... (resetDistanceMode, renderOceanSquares, renderSubGrid, renderDistanceLines, renderCities, renderHeader, renderSidebar - inchang√©s dans leur structure, mais la logique des events est dans le code ci-dessus)

            const resetDistanceMode = useCallback(() => {
                setDistanceMode(false);
                setCitiesForDistance([]);
            }, []);

            // Rendu des carr√©s d'oc√©an
            const renderOceanSquares = useCallback(() => {
                const oceanSquares = [];
                for (let x = 0; x < 10; x++) {
                    for (let y = 0; y < 10; y++) {
                        const grepolisOceanNum = getGrepolisOcean(x * 100 + 1, y * 100 + 1); 
                        const isOccupied = cities.some(city => city.ocean === grepolisOceanNum);
                        const oceanX = x;
                        const oceanY = y;
                        const isEven = (oceanX % 2 === 0) === (oceanY % 2 === 0); 
                        
                        if (viewMode === 'detailed' || isOccupied) { 
                            oceanSquares.push(
                                <g key={grepolisOceanNum}>
                                    <rect 
                                        x={oceanX * 100} y={oceanY * 100} 
                                        width={100} height={100} 
                                        fill={isEven ? '#1e3a5f' : '#2d4a6f'} 
                                        stroke="#0f172a" strokeWidth="0.5" 
                                        opacity={isOccupied ? 1 : 0.3} 
                                    />
                                    <text 
                                        x={oceanX * 100 + 50} y={oceanY * 100 + 50} 
                                        textAnchor="middle" dy="0.35em" 
                                        fill={isOccupied ? '#fbbf24' : '#64748b'} 
                                        fontSize="12" fontWeight="bold" 
                                        opacity={isOccupied ? 0.9 : 0.3} 
                                    >
                                        {grepolisOceanNum} 
                                    </text>
                                </g>
                            );
                        }
                    }
                }
                return oceanSquares;
            }, [cities]);
            
            // Rendu de la grille secondaire 5x5
            const renderSubGrid = useCallback(() => {
                if (!showSubGrid) return null; 

                const subGridLines = [];
                for (let x = 0; x <= 1000; x += 20) {
                    subGridLines.push(
                        <line key={`vline-${x}`} x1={x} y1={0} x2={x} y2={1000} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                for (let y = 0; y <= 1000; y += 20) {
                    subGridLines.push(
                        <line key={`hline-${y}`} x1={0} y1={y} x2={1000} y2={y} 
                            stroke="white" strokeWidth="0.2" opacity="0.2" />
                    );
                }
                return subGridLines;
            }, []);

            // Rendu des lignes de distance
            const renderDistanceLines = useCallback(() => {
                if (citiesForDistance.length < 2) return null;
                const [city1, city2] = citiesForDistance;
                const distance = calculateDistance(city1.x, city1.y, city2.x, city2.y);
                return (
                    <g>
                        <line x1={city1.x} y1={city1.y} x2={city2.x} y2={city2.y} 
                            stroke="#10b981" strokeWidth="1.5" className="distance-line" />
                        
                        <text 
                            x={(city1.x + city2.x) / 2} y={(city1.y + city2.y) / 2} 
                            textAnchor="middle" dy="-0.5em" 
                            fill="#10b981" fontSize={Math.max(4, 14 / transform.scale)} 
                            fontWeight="bold" 
                            style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                        >
                            {distance}
                        </text>
                    </g>
                );
            }, [citiesForDistance, transform.scale]);

            // Rendu des villes (Logique de couleur et taille ajust√©e)
            const renderCities = useMemo(() => {
                return Object.entries(groupedCities).map(([key, citiesAtLocation]) => {
                    const [x, y] = key.split(',').map(Number);
                    
                    let cityColor;
                    
                    if (colorMode === 'ocean') {
                        cityColor = oceanColors[citiesAtLocation[0].ocean] || '#ccc';
                    } else {
                        const allianceCounts = citiesAtLocation.reduce((acc, c) => {
                            acc[c.alliance_id] = (acc[c.alliance_id] || 0) + 1;
                            return acc;
                        }, {});
                        
                        let dominantAllianceId = 0;
                        let maxCount = 0;
                        
                        for (const id in allianceCounts) {
                            if (allianceCounts[id] > maxCount) {
                                maxCount = allianceCounts[id];
                                dominantAllianceId = Number(id);
                            }
                        }
                        cityColor = allianceColors[dominantAllianceId] || '#94a3b8';
                    }
                    
                    const payload = citiesAtLocation.length > 1 ? citiesAtLocation : citiesAtLocation[0];
                    
                    const isHovered = hoveredCity && (
                        (Array.isArray(hoveredCity) && hoveredCity[0].x === x && hoveredCity[0].y === y) ||
                        (!Array.isArray(hoveredCity) && hoveredCity.x === x && hoveredCity.y === y)
                    );
                    const isSelected = selectedCity && (
                        (Array.isArray(selectedCity) && selectedCity[0].x === x && selectedCity[0].y === y) ||
                        (!Array.isArray(selectedCity) && selectedCity.x === x && selectedCity.y === y)
                    );
                    const isInDistanceSelection = citiesForDistance.some(c => c.x === x && c.y === y);

                    return (
                        <g key={key}>
                            {/* Cercle principal de la ville/cluster */}
                            <circle 
                                cx={x} cy={y} 
                                r={Math.max(1, 4 / transform.scale)} 
                                fill={cityColor} 
                                stroke={isInDistanceSelection ? '#10b981' : (isSelected ? '#fff' : isHovered ? '#fff' : cityColor)} 
                                strokeWidth={isInDistanceSelection ? 2 : (isSelected ? 1.5 : isHovered ? 1 : 0)}
                                opacity={isInDistanceSelection ? 1 : (isHovered || isSelected ? 1 : 0.9)}
                                onMouseEnter={() => setHoveredCity(payload)}
                                onMouseLeave={() => setHoveredCity(null)}
                                onClick={(e) => handleCityClick(e, payload)}
                                onTouchEnd={(e) => handleCityClick(e, payload)} 
                                style={{ cursor: 'pointer' }}
                            />
                            {/* Indicateur de nombre pour les clusters (Taille -40%) */}
                            {citiesAtLocation.length > 1 && (
                                <text 
                                    x={x} y={y} 
                                    textAnchor="middle" dy="0.3em" 
                                    fill="white" 
                                    fontSize={Math.max(2, 4.8 / transform.scale)} 
                                    fontWeight="bold" 
                                    style={{ pointerEvents: 'none' }}
                                >
                                    {citiesAtLocation.length}
                                </text>
                            )}
                            {/* Tooltip au survol/s√©lection */}
                            {(isHovered || isSelected) && !distanceMode && transform.scale > 0.5 && (
                                <>
                                    <text 
                                        x={x} y={y - 8 - (10 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#fbbf24" 
                                        fontSize={Math.max(4, 12 / transform.scale)} 
                                        fontWeight="bold" 
                                        style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                                    >
                                        {citiesAtLocation[0].name} {citiesAtLocation.length > 1 ? `(+${citiesAtLocation.length - 1})` : ''}
                                    </text>
                                    <text 
                                        x={x} y={y - 4 - (5 / transform.scale)} 
                                        textAnchor="middle" 
                                        fill="#94a3b8" 
                                        fontSize={Math.max(3, 10 / transform.scale)} 
                                        style={{ pointerEvents: 'none', textShadow: '0 0 3px #0f172a' }}
                                    >
                                        ({x}, {y}) - {citiesAtLocation[0].player_name}
                                    </text>
                                </>
                            )}
                        </g>
                    );
                });
            }, [groupedCities, hoveredCity, selectedCity, citiesForDistance, oceanColors, allianceColors, colorMode, distanceMode, handleCityClick, transform.scale]);
            
            // Composant de l'en-t√™te
            const renderHeader = () => (
                <div className="bg-slate-800 p-4 shadow-lg sticky top-0 z-10">
                    <h1 className="text-xl sm:text-2xl font-bold text-amber-400 mb-4 flex items-center gap-2">
                         <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0l-4.243-4.243m10.606 0a2 2 0 110-2 2 2 0 010 2zm-10.606 0a2 2 0 110-2 2 2 0 010 2zM6 10h2m4 0h2m4 0h2m-10 0V4h12v6" />
                        </svg>
                        Carte des Villes de l'Alliance
                    </h1>
                    
                    <div className="flex flex-wrap items-center gap-3">
                        {/* Rechercher une ville */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="üîç Rechercher une ville..."
                                value={search}
                                onChange={(e) => setSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-44 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                        </div>

                        {/* Rechercher un joueur */}
                        <div className="relative w-full sm:w-auto">
                            <input 
                                type="text"
                                placeholder="üë§ Rechercher un joueur..."
                                value={playerSearch}
                                onChange={(e) => setPlayerSearch(e.target.value)}
                                className="pl-10 pr-4 py-2 bg-slate-700 text-white rounded-lg w-full sm:w-44 focus:ring-amber-500 focus:border-amber-500"
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14c3.486 0 5.122 1.981 5.64 3.551.493 1.52-.39 2.449-1.957 2.449H8.317c-1.567 0-2.45-1.129-1.957-2.449C6.878 15.981 8.514 14 12 14z" /></svg>
                        </div>
                        
                        {/* Filtre Oc√©an */}
                        <select
                            value={selectedOcean}
                            onChange={(e) => setSelectedOcean(e.target.value)}
                            className="bg-slate-700 text-white py-2 px-3 rounded-lg focus:ring-amber-500 focus:border-amber-500 w-full sm:w-auto"
                        >
                            {oceans.map(ocean => (
                                <option key={ocean} value={ocean}>
                                    {ocean === 'all' ? 'Tous les Oc√©ans' : `Oc√©an ${ocean}`}
                                </option>
                            ))}
                        </select>
                        
                        {/* Boutons de contr√¥le */}
                        <div className="flex flex-wrap gap-2 w-full sm:w-auto">
                            <button onClick={() => setDistanceMode(!distanceMode)} className={`flex-1 sm:flex-none px-3 py-2 rounded-lg transition-colors ${ 
                                distanceMode ? 'bg-green-500 hover:bg-green-600 text-white' : 'bg-slate-600 hover:bg-slate-500 text-slate-300' 
                            }`}> 
                                üìè Distance 
                            </button>
                            <button onClick={() => zoomToOccupiedAreas(mapBounds)} className="flex-1 sm:flex-none px-3 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 transition-colors" > 
                                üîç Zoom Zones 
                            </button>
                            <button onClick={() => setTransform({ x: 0, y: 0, scale: 1 })} className="flex-1 sm:flex-none px-3 py-2 bg-slate-600 text-slate-300 rounded-lg hover:bg-slate-500 transition-colors" > 
                                Reset Zoom 
                            </button>
                        </div>
                    </div>

                    <div className="mt-3 text-slate-300 text-xs sm:text-sm flex gap-4 flex-wrap">
                        {loading ? (
                            <span className="text-amber-400 font-semibold">Chargement des donn√©es...</span>
                        ) : dataError ? (
                            <span className="text-red-400 font-semibold">Erreur de donn√©es: {dataError}</span>
                        ) : (
                            <>
                                <span> 
                                    <span className="font-semibold text-amber-400">{filteredCities.length}</span> villes affich√©es 
                                </span>
                                <span> 
                                    <span className="font-semibold text-amber-400">{Object.keys(groupedCities).length}</span> positions uniques 
                                </span>
                                <span> 
                                    <span className="font-semibold text-amber-400">{cities.length}</span> villes totales 
                                </span>
                                {lastUpdate && lastUpdate !== 'Date inconnue' && (
                                    <span className="text-yellow-400 font-semibold flex items-center gap-1"> 
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                        Mise √† jour: {lastUpdate} 
                                    </span>
                                )}
                            </>
                        )}
                        {distanceMode && (
                            <span className="text-green-400 font-semibold"> üìè Mode Distance Activ√© - Cliquez sur 2 villes </span>
                        )}
                        <span className={`font-semibold ${colorMode === 'alliance' ? 'text-indigo-400' : 'text-blue-400'}`}> 
                            üé® Couleur par {colorMode === 'alliance' ? 'Alliance' : 'Oc√©an (Filtre Joueur Actif)'} 
                        </span>
                    </div>
                </div>
            );


            // Composant de la Barre Lat√©rale
            const renderSidebar = () => {
                const targetCityOrCluster = selectedCity || hoveredCity;

                if (loading) {
                    return (
                        <div className="w-full sm:w-80 p-4 bg-slate-800 text-slate-300 flex-shrink-0 overflow-y-auto sidebar">
                            <div className="text-center py-10">
                                <p className="text-amber-400">Chargement des donn√©es...</p>
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-amber-400 mx-auto mt-4"></div>
                            </div>
                        </div>
                    );
                }
                
                if (dataError) {
                    return (
                        <div className="w-full sm:w-80 p-4 bg-slate-800 text-slate-300 flex-shrink-0 overflow-y-auto sidebar">
                             <div className="text-center py-10">
                                <p className="text-red-400 font-bold">Erreur Critique de Donn√©es</p>
                                <p className="text-sm mt-2">{dataError}</p>
                                <p className="text-xs mt-4">V√©rifiez les fichiers TXT et la console pour les d√©tails.</p>
                            </div>
                        </div>
                    );
                }
                
                const isCluster = Array.isArray(targetCityOrCluster) && targetCityOrCluster.length > 1;
                const targetCity = isCluster ? targetCityOrCluster[0] : targetCityOrCluster; 

                return (
                    <div className="w-full sm:w-80 p-4 bg-slate-800 text-slate-300 flex-shrink-0 overflow-y-auto sidebar">
                        <h2 className="text-xl font-bold text-white mb-4">Informations</h2>
                        
                        {targetCityOrCluster ? (
                            
                            // 1. AFFICHAGE DES D√âTAILS DU CLUSTER
                            isCluster ? (
                                <div className="space-y-4">
                                    <h3 className="text-lg font-semibold text-amber-400 border-b border-slate-700 pb-2">
                                        <span className="text-white">Cluster (Position</span>: {targetCity.x}, {targetCity.y})
                                    </h3>
                                    
                                    {/* CLUSTER SUMMARY */}
                                    <div className="bg-slate-700 p-3 rounded-lg space-y-1">
                                        <div className="font-semibold text-white">Total Villes dans le Cluster:</div>
                                        <div className="text-xl font-bold text-amber-300">{targetCityOrCluster.length}</div>
                                        <div className="text-sm">Oc√©an: {targetCity.ocean}</div>
                                        <div className="text-sm border-t border-slate-600 pt-1 mt-1">
                                            Alliance dominante: <span className="font-semibold" style={{ color: allianceColors[targetCity.alliance_id] }}>{targetCity.alliance_name}</span> (Couleur du point)
                                        </div>
                                    </div>
                                    
                                    {/* CLUSTER CITY LIST */}
                                    <div className="bg-slate-700 p-3 rounded-lg">
                                        <div className="font-semibold text-white border-b border-slate-600 pb-1 mb-2">Liste des Villes:</div>
                                        <div className="space-y-1 max-h-40 sm:max-h-60 overflow-y-auto">
                                            {targetCityOrCluster.map((city, index) => (
                                                <div key={index} className="text-xs border-b border-slate-600 pb-1 last:border-b-0">
                                                    <div className="font-bold truncate" title={city.name}>
                                                        {city.name} (Emplacement {city.island_pos}) / ({city.points.toLocaleString('fr-FR')} pts)
                                                    </div>
                                                    <div className="flex justify-between items-center text-slate-400">
                                                        <span 
                                                            style={{ color: allianceColors[city.alliance_id] }}
                                                            className="font-semibold truncate mr-2"
                                                            title={city.player_name}
                                                        >
                                                            {city.player_name}
                                                        </span>
                                                        <span 
                                                            style={{ color: allianceColors[city.alliance_id] }}
                                                            className="text-[10px] truncate"
                                                            title={city.alliance_name}
                                                        >
                                                            [{city.alliance_name}]
                                                        </span>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                            ) : (

                                // 2. AFFICHAGE DES D√âTAILS D'UNE VILLE UNIQUE
                                <div className="space-y-4">
                                    <h3 className="text-lg font-semibold text-amber-400 border-b border-slate-700 pb-2">
                                        <span className="text-white">Ville S√©lectionn√©e</span>: {targetCity.name}
                                    </h3>

                                    {/* Informations de base de la ville */}
                                    <div className="bg-slate-700 p-3 rounded-lg space-y-1">
                                        <div className="font-semibold text-white">Coordonn√©es:</div>
                                        <div className="text-sm">({targetCity.x}, {targetCity.y}) - Oc√©an {targetCity.ocean}</div>
                                        <div className="text-sm">Emplacement sur l'√Æle: <span className="font-bold text-amber-300">{targetCity.island_pos}</span></div>
                                        <div className="text-sm">Points de la ville: {targetCity.points.toLocaleString('fr-FR')}</div>
                                    </div>
                                    
                                    {/* D√©tails du Joueur (Nom du joueur color√© par l'alliance) */}
                                    <div className="bg-slate-700 p-3 rounded-lg space-y-1">
                                        <div className="font-semibold text-white border-b border-slate-600 pb-1 mb-1">D√©tails du Joueur</div>
                                        <div className="flex justify-between text-sm">
                                            <span className="text-amber-300">Nom:</span> 
                                            <span 
                                                className="font-bold"
                                                style={{ color: allianceColors[targetCity.alliance_id] }}
                                            >
                                                {targetCity.player_name}
                                            </span>
                                        </div>
                                        <div className="flex justify-between text-sm">
                                            <span className="text-amber-300">Points Joueur:</span> 
                                            <span>{targetCity.player_points.toLocaleString('fr-FR')}</span>
                                        </div>
                                        <div className="flex justify-between text-sm">
                                            <span className="text-amber-300">Nombre de Villes:</span> 
                                            <span>{targetCity.player_towns_count}</span>
                                        </div>
                                        <div className="flex justify-between text-sm">
                                            <span className="text-amber-300">Points Offensifs:</span> 
                                            <span>{targetCity.player_off_points.toLocaleString('fr-FR')}</span> 
                                        </div>
                                        <div className="flex justify-between text-sm">
                                            <span className="text-amber-300">Points D√©fensifs:</span> 
                                            <span>{targetCity.player_def_points.toLocaleString('fr-FR')}</span>
                                        </div>
                                    </div>

                                    {/* D√©tails de l'Alliance */}
                                    {targetCity.alliance_name && (
                                        <div className="bg-slate-700 p-3 rounded-lg space-y-1">
                                            <div className="font-semibold text-white border-b border-slate-600 pb-1 mb-1">D√©tails de l'Alliance</div>
                                            <div className="flex justify-between text-sm">
                                                <span className="text-amber-300">Alliance:</span> 
                                                <span className="font-bold" style={{ color: allianceColors[targetCity.alliance_id] }}>{targetCity.alliance_name}</span>
                                            </div>
                                            <div className="flex justify-between text-sm">
                                                <span className="text-amber-300">Membres:</span> 
                                                <span>{targetCity.alliance_members}</span>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )
                        ) : distanceMode && citiesForDistance.length > 0 ? (
                            <div className="p-4 bg-slate-700 rounded-lg shadow-inner">
                                <h3 className="text-lg font-semibold text-green-400 mb-2">Mode Distance</h3>
                                {citiesForDistance.length === 1 && (
                                    <p>Ville 1 s√©lectionn√©e : <span className="font-bold">{citiesForDistance[0].name}</span>. Cliquez sur une deuxi√®me ville.</p>
                                )}
                                {citiesForDistance.length === 2 && (
                                    <div className="text-center">
                                        <div className="text-green-200 text-sm">Distance calcul√©e:</div>
                                        <div className="text-green-100 font-bold text-xl text-center mt-2">
                                            {calculateDistance(
                                                citiesForDistance[0].x, 
                                                citiesForDistance[0].y, 
                                                citiesForDistance[1].x, 
                                                citiesForDistance[1].y 
                                            )} unit√©s
                                        </div>
                                    </div>
                                )}
                                <button onClick={resetDistanceMode} className="w-full mt-4 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                                    Quitter le mode Distance
                                </button>
                            </div>
                        ) : (
                            <div className="p-4 bg-slate-700 rounded-lg shadow-inner">
                                <p>Survolez ou cliquez sur une ville pour afficher ses informations d√©taill√©es (joueur, alliance, points, etc.) ici.</p>
                                <div className="pt-4 mt-4 border-t border-slate-700">
                                    <h4 className="text-sm font-semibold text-amber-400 mb-2">Contr√¥les</h4>
                                    <div className="text-sm text-slate-300 space-y-1">
                                        <div>üñ±Ô∏è <strong>Molette</strong> : Zoom avant/arri√®re</div>
                                        <div>üëÜ <strong>Glisser un doigt</strong> : D√©placer la carte</div>
                                        <div>üëÜ <strong>Pincer/√âcarter deux doigts</strong> : Zoomer</div>
                                        <div>üëÜ <strong>Tap court</strong> : S√©lectionner une ville</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* L√©gende des Couleurs */}
                        {(!targetCityOrCluster || (targetCity && colorMode === 'alliance')) && alliances.length > 0 && (
                            <div className="mt-6 p-4 bg-slate-700 rounded-lg">
                                <h4 className="text-sm font-semibold text-indigo-400 mb-2">L√©gende des Alliances ({alliances.length})</h4>
                                <div className="max-h-60 overflow-y-auto space-y-1 text-xs">
                                    {alliances.sort((a, b) => b.points - a.points).map(alliance => (
                                        <div key={alliance.id} className="flex items-center justify-between">
                                            <div className="flex items-center">
                                                <span 
                                                    className="w-2 h-2 rounded-full mr-2 flex-shrink-0" 
                                                    style={{ backgroundColor: allianceColors[alliance.id] || '#ccc' }}
                                                ></span>
                                                <span className="truncate">{alliance.name}</span>
                                            </div>
                                            <span className="text-slate-400 ml-2 flex-shrink-0">({alliance.members})</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                    </div>
                );
            };

            return (
                <div className="w-full h-screen bg-slate-900 flex flex-col">
                    {/* En-t√™te avec contr√¥les */}
                    {renderHeader()}

                    {/* Conteneur principal: Carte + Sidebar */}
                    {/* Utilisation de md:flex-row pour forcer la colonne sur la plupart des tablettes */}
                    <div className="flex flex-1 overflow-hidden md:flex-row flex-col">
                        
                        {/* Zone de la carte */}
                        <div className="flex-1 relative overflow-hidden map-wrapper">
                            <svg 
                                ref={mapRef} 
                                viewBox="0 0 1000 1000" 
                                preserveAspectRatio="xMidYMid meet"
                                className="w-full h-full map-container"
                                style={{
                                    transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                                    transformOrigin: 'top left'
                                }}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                
                                onTouchStart={handleTouchStart}  
                                onTouchMove={handleTouchMove}    
                                onTouchEnd={handleTouchEnd}      
                                onTouchCancel={handleTouchEnd}   /* Ajout pour garantir la fin du geste */
                            >
                                <g>
                                    {renderOceanSquares()} 
                                    {renderSubGrid()} 
                                    {renderDistanceLines()} 
                                    {renderCities}
                                </g>
                            </svg>
                        </div>
                        
                        {/* Barre lat√©rale droite/bas */}
                        {renderSidebar()}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<GrepolisMap />, document.getElementById('root'));
    </script>
</body>
</html>