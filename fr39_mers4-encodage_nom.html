<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grepolis FR39 - Cartes des Océans</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const GrepolisOceans = () => {
            const [isFetching, setIsFetching] = useState(true);
            const [lastUpdate, setLastUpdate] = useState(null);
            const [cities, setCities] = useState([]);
            const [alliances, setAlliances] = useState({});
            const [players, setPlayers] = useState({});
            
            const [selectedAlliance, setSelectedAlliance] = useState('all');
            const [search, setSearch] = useState('');
            const [hoveredCity, setHoveredCity] = useState(null);
            const [selectedCity, setSelectedCity] = useState(null);
            const [customColors, setCustomColors] = useState({});
            const [hiddenAlliances, setHiddenAlliances] = useState(new Set());
            const [selectedOcean, setSelectedOcean] = useState('25');
            const [viewMode, setViewMode] = useState('ocean'); 

            // --- NOUVELLE FONCTION POUR GÉRER LES ACCENTS ---
            const fetchAndDecode = async (url) => {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erreur lors du chargement de ${url}`);
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('utf-8'); // Force le décodage UTF-8
                return decoder.decode(buffer);
            };

            const generateColor = (index) => {
                const colors = [
                    '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
                    '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1',
                    '#14b8a6', '#a855f7', '#22c55e', '#eab308', '#fb923c',
                    '#0ea5e9', '#d946ef', '#64748b', '#facc15', '#2dd4bf'
                ];
                return colors[index % colors.length];
            };
            
            const formatDate = (date) => {
                if (!date) return 'N/A';
                const options = { 
                    day: '2-digit', month: '2-digit', year: 'numeric', 
                    hour: '2-digit', minute: '2-digit', second: '2-digit',
                };
                return date.toLocaleString('fr-FR', options);
            };
            
            const loadDataFromGitHub = async () => {
                setIsFetching(true);
                let alliancesData = {};
                let playersData = {};
                let updateDate = null; 

                try {
                    // Chargement de la date
                    try {
                        const dateText = await fetchAndDecode('./last_update.txt');
                        const cleanedText = dateText.trim();
                        const parts = cleanedText.split(' ');
                        if (parts.length >= 2) {
                            const dateParts = parts[0].split('/');
                            const timePart = parts[1];
                            const dateString = `${dateParts[1]}/${dateParts[0]}/${dateParts[2]} ${timePart}`;
                            const parsedDate = new Date(dateString);
                            if (!isNaN(parsedDate)) updateDate = parsedDate;
                        }
                    } catch (e) {
                        console.error("Date introuvable");
                    }

                    // 1. Charger Alliances.txt avec décodage UTF-8
                    const alliancesText = await fetchAndDecode('./alliances.txt');
                    alliancesText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length >= 2) {
                                alliancesData[parts[0]] = {
                                    id: parts[0],
                                    name: parts[1],
                                    points: parts[2] || '0',
                                    towns: parts[3] || '0',
                                    members: parts[4] || '0',
                                    rank: parts[5] || '0'
                                };
                            }
                        }
                    });
                    setAlliances(alliancesData);

                    // 2. Charger Players.txt avec décodage UTF-8
                    const playersText = await fetchAndDecode('./players.txt');
                    playersText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length >= 2) {
                                playersData[parts[0]] = {
                                    id: parts[0],
                                    name: parts[1],
                                    alliance_id: parts[2] || null,
                                    points: parts[3] || '0',
                                    rank: parts[4] || '0',
                                    towns: parts[5] || '0'
                                };
                            }
                        }
                    });
                    setPlayers(playersData);

                    // 3. Charger Towns.txt avec décodage UTF-8
                    const townsText = await fetchAndDecode('./towns.txt');
                    const townsData = [];
                    townsText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length >= 7) {
                                const x = parseInt(parts[3]);
                                const y = parseInt(parts[4]);
                                const oceanX = Math.floor(x / 100);
                                const oceanY = Math.floor(y / 100);
                                const ocean = oceanX * 10 + oceanY;
                                
                                townsData.push({
                                    id: parts[0], player_id: parts[1], name: parts[2],
                                    x: x, y: y, island: parts[5], points: parts[6],
                                    ocean: ocean.toString().padStart(2, '0')
                                });
                            }
                        }
                    });
                    
                    const enrichedTowns = townsData.map(town => {
                        const player = playersData[town.player_id];
                        const allianceId = player?.alliance_id;
                        return {
                            ...town,
                            player_name: player?.name || 'Inconnu',
                            alliance_id: allianceId,
                            alliance_name: allianceId && alliancesData[allianceId] ? alliancesData[allianceId].name : 'Sans alliance'
                        };
                    });

                    setCities(enrichedTowns);
                    
                } catch (error) {
                    console.error("Erreur :", error);
                    alert("Erreur: Impossible de charger les fichiers.");
                } finally {
                    setIsFetching(false);
                    setLastUpdate(updateDate || new Date()); 
                }
            };

            useEffect(() => {
                loadDataFromGitHub();
            }, []);
            
            // Logique de rendu (identique à l'originale pour conserver le fonctionnement)
            const getOceanViewBox = (ocean) => {
                const oceanNum = parseInt(ocean);
                const oceanX = Math.floor(oceanNum / 10);
                const oceanY = oceanNum % 10;
                return `${oceanX * 100} ${oceanY * 100} 100 100`;
            };

            const toggleAllianceVisibility = (alliance) => {
                setHiddenAlliances(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(alliance)) newSet.delete(alliance);
                    else newSet.add(alliance);
                    return newSet;
                });
            };

            const handleColorChange = (alliance, color) => {
                setCustomColors(prev => ({ ...prev, [alliance]: color }));
            };
            
            const availableOceans = [...new Set(cities.map(c => c.ocean))].sort();
            const citiesInSelectedOcean = cities.filter(city => city.ocean === selectedOcean);
            const uniqueAlliances = [...new Set(citiesInSelectedOcean.map(c => c.alliance_name))].sort();
            
            const allianceColors = {};
            uniqueAlliances.forEach((alliance, index) => {
                allianceColors[alliance] = customColors[alliance] || generateColor(index);
            });

            const filteredCities = citiesInSelectedOcean.filter(city => {
                const matchSearch = city.name.toLowerCase().includes(search.toLowerCase()) ||
                                  city.player_name.toLowerCase().includes(search.toLowerCase());
                const matchAlliance = selectedAlliance === 'all' || city.alliance_name === selectedAlliance;
                const isVisible = !hiddenAlliances.has(city.alliance_name);
                return matchSearch && matchAlliance && isVisible;
            });

            const groupedCities = {};
            filteredCities.forEach(city => {
                const key = `${city.x},${city.y}`;
                if (!groupedCities[key]) groupedCities[key] = [];
                groupedCities[key].push(city);
            });

            const oceanStats = {};
            cities.forEach(city => {
                if (!oceanStats[city.ocean]) {
                    oceanStats[city.ocean] = { totalCities: 0, alliances: new Set(), totalPoints: 0 };
                }
                oceanStats[city.ocean].totalCities++;
                oceanStats[city.ocean].alliances.add(city.alliance_name);
                oceanStats[city.ocean].totalPoints += parseInt(city.points);
            });
            
            if (isFetching) { 
                return (
                    <div className="w-full h-screen bg-slate-900 flex items-center justify-center">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-amber-400 mx-auto"></div>
                            <p className="text-slate-300 mt-4 text-xl">Chargement des données...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-screen bg-slate-900 flex flex-col">
                    <div className="bg-slate-800 p-4 shadow-lg">
                        <div className="flex flex-wrap justify-between items-center gap-4 mb-2"> 
                            <h1 className="text-2xl font-bold text-amber-400 flex items-center gap-2">
                                Grepolis FR39 - Océan {selectedOcean}
                            </h1>
                            <div className="text-slate-400 text-sm italic">
                                Mis à jour le : <span className="text-amber-300 font-medium">{formatDate(lastUpdate)}</span>
                            </div>
                            <div className="flex gap-2">
                                <select
                                    value={selectedOcean}
                                    onChange={(e) => setSelectedOcean(e.target.value)}
                                    className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600 focus:outline-none"
                                >
                                    {availableOceans.map(ocean => (
                                        <option key={ocean} value={ocean}>Océan {ocean}</option>
                                    ))}
                                </select>
                                <button
                                    onClick={() => setViewMode(viewMode === 'ocean' ? 'world' : 'ocean')}
                                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium"
                                >
                                    {viewMode === 'ocean' ? 'Vue Monde' : 'Vue Océan'}
                                </button>
                            </div>
                        </div>
                        <div className="flex gap-4 flex-wrap">
                            <input
                                type="text"
                                placeholder="Rechercher une ville ou un joueur..."
                                value={search}
                                onChange={(e) => setSearch(e.target.value)}
                                className="flex-1 min-w-64 pl-4 pr-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600 focus:outline-none"
                            />
                            <select
                                value={selectedAlliance}
                                onChange={(e) => setSelectedAlliance(e.target.value)}
                                className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600 focus:outline-none"
                            >
                                <option value="all">Toutes les alliances</option>
                                {uniqueAlliances.map(alliance => (
                                    <option key={alliance} value={alliance}>{alliance}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div className="flex-1 flex overflow-hidden">
                        <div className="flex-1 overflow-auto bg-slate-950 p-8">
                            {viewMode === 'ocean' ? (
                                <svg
                                    viewBox={getOceanViewBox(selectedOcean)}
                                    className="w-full h-full"
                                    style={{ minWidth: '1000px', minHeight: '1000px' }}
                                >
                                    <rect 
                                        x={Math.floor(parseInt(selectedOcean) / 10) * 100} 
                                        y={(parseInt(selectedOcean) % 10) * 100} 
                                        width="100" height="100" fill="#1e3a5f" stroke="#0f172a" strokeWidth="0.5" 
                                    />
                                    {Object.entries(groupedCities).map(([coords, citiesAtLocation]) => {
                                        const [x, y] = coords.split(',').map(Number);
                                        const isHovered = hoveredCity && citiesAtLocation.some(c => c.id === hoveredCity.id);
                                        const isSelected = selectedCity && citiesAtLocation.some(c => c.id === selectedCity.id);
                                        const color = allianceColors[citiesAtLocation[0].alliance_name] || '#6b7280';
                                        
                                        return (
                                            <g key={coords} onMouseEnter={() => setHoveredCity(citiesAtLocation[0])} onMouseLeave={() => setHoveredCity(null)} onClick={() => setSelectedCity(citiesAtLocation[0])}>
                                                <circle cx={x} cy={y} r={isHovered || isSelected ? 2.5 : 1.5} fill={color} stroke={isSelected ? '#fbbf24' : isHovered ? '#fff' : color} strokeWidth={isSelected ? 1 : 0.5} style={{ cursor: 'pointer' }} />
                                            </g>
                                        );
                                    })}
                                </svg>
                            ) : (
                                <svg viewBox="0 0 1000 1000" className="w-full h-full" style={{ minWidth: '1000px', minHeight: '1000px' }}>
                                    {Array.from({ length: 100 }).map((_, i) => {
                                        const id = i.toString().padStart(2, '0');
                                        const x = Math.floor(i / 10);
                                        const y = i % 10;
                                        return (
                                            <rect key={id} x={x*100} y={y*100} width="100" height="100" fill={id === selectedOcean ? '#334155' : '#1e293b'} stroke="#475569" onClick={() => setSelectedOcean(id)} style={{ cursor: 'pointer' }} />
                                        );
                                    })}
                                </svg>
                            )}
                        </div>

                        <div className="w-80 bg-slate-800 overflow-y-auto p-4 border-l border-slate-700">
                            <h3 className="text-lg font-bold text-amber-400 mb-4">
                                {hoveredCity || selectedCity ? 'Détails' : 'Alliances'}
                            </h3>
                            {/* Les détails et la liste des alliances s'afficheront ici avec les bons caractères */}
                            {(hoveredCity || selectedCity) ? (
                                <div className="bg-slate-700 p-3 rounded-lg">
                                    <div className="font-semibold text-white">{(hoveredCity || selectedCity).name}</div>
                                    <div className="text-sm text-slate-300 mt-2">
                                        Joueur: {(hoveredCity || selectedCity).player_name}<br/>
                                        Alliance: {(hoveredCity || selectedCity).alliance_name}
                                    </div>
                                </div>
                            ) : (
                                <div className="space-y-2">
                                    {uniqueAlliances.map(alliance => (
                                        <div key={alliance} className="flex items-center gap-2 text-slate-200 bg-slate-700 p-2 rounded">
                                            <div className="w-3 h-3 rounded-full" style={{backgroundColor: allianceColors[alliance]}}></div>
                                            {alliance}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<GrepolisOceans />, document.getElementById('root'));
    </script>
</body>
</html>